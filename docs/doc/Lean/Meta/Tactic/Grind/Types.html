<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.Grind.Types</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.Grind.Types";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">Grind</span>.<span class="name">Types</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Lean/HeadIndex.html">Lean.HeadIndex</a></li><li><a href="../../../.././Lean/PrettyPrinter.html">Lean.PrettyPrinter</a></li><li><a href="../../../.././Init/Data/Queue.html">Init.Data.Queue</a></li><li><a href="../../../.././Init/Grind/Tactics.html">Init.Grind.Tactics</a></li><li><a href="../../../.././Lean/Parser/Do.html">Lean.Parser.Do</a></li><li><a href="../../../.././Lean/Meta/Match/MatchEqsExt.html">Lean.Meta.Match.MatchEqsExt</a></li><li><a href="../../../.././Std/Data/TreeSet/Basic.html">Std.Data.TreeSet.Basic</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html">Lean.Meta.Tactic.Grind.AlphaShareCommon</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Attr.html">Lean.Meta.Tactic.Grind.Attr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html">Lean.Meta.Tactic.Grind.EMatchTheorem</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html">Lean.Meta.Tactic.Grind.ExprPtr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ExtAttr.html">Lean.Meta.Tactic.Grind.ExtAttr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Simp/Types.html">Lean.Meta.Tactic.Simp.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.Grind.Types" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isDefEqD"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqD</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtensionStateSpec"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionStateSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtensionState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitSource.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitSource.toMessageData"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span>.<span class="name">toMessageData</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Trace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Trace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCounters.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitDiagInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">MethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withSplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getOrderingEqExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getIntExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getSymbolPriorities"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getSymbolPriorities</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveAppOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveAppOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveSplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveSplitDiagInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverTerms.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprSolverTerms.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENode.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprENode.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENodeMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedNewRawFact.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCaseTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.source"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">source</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoal.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Fallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.applyFallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">applyFallback</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.canon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">canon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtension.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.registerSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerSolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.setMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">setMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mkInitialStates"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkInitialStates</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoalM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.modifyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">modifyState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getStateCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getStateCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.checkInvariants"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">checkInvariants</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mbtc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mbtc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.propagateDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">propagateDiseqs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isSameSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isSameSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.markTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">markTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">hasTermAtRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PendingSolverPropagations"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mergeTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mergeTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PendingSolverPropagations.propagate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span>.<span class="name">propagate</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.Grind.congrPlaceholderProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L24-L25">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></div><p>We use this auxiliary constant to mark delayed congruence proofs.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof">Lean.Meta.Grind.congrPlaceholderProof</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">&quot;[congruence]&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.congrPlaceholderProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isDefEqD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L27-L29">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqD</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">s</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Similar to <code>isDefEq</code>, but ensures default transparency is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">t</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.withDefault">Lean.Meta.withDefault</a> <span class="fn">(<a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.isDefEq">Lean.Meta.isDefEq</a> <span class="fn">t</span> <span class="fn">s</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isDefEqD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isInterpreted"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L31-L37">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is <code><a href="../../../.././Init/Prelude.html#True">True</a></code>, <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, or a literal value.
See <code><a href="../../../.././Lean/Meta/LitValues.html">Lean.Meta.LitValues</a></code> for supported literals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted">Lean.Meta.Grind.isInterpreted</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isTrue">isTrue</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isFalse">isFalse</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">do
    let <span class="fn">y</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span>
    <span class="fn"><span class="fn">(fun (<span class="fn">y</span> : <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/LitValues.html#Lean.Meta.isLitValue">Lean.Meta.isLitValue</a> <span class="fn">e</span></span>)</span> <span class="fn">y</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInterpreted" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L39-L43">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug.proofs"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L45-L49">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.warning"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L51-L55">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtensionStateSpec"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L57-L58">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionStateSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>) × <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span></span></div></div><p>Opaque solver extension state.</p></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtensionState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L59-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">Lean.Meta.Grind.SolverExtensionState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec">Lean.Meta.Grind.SolverExtensionStateSpec</a>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtensionState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtensionState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L60-L60">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtensionState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtensionState">Lean.Meta.Grind.instInhabitedSolverExtensionState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec">Lean.Meta.Grind.SolverExtensionStateSpec</a>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitSource"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L62-L81">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split source. That is, where it came from.
We store the current source in the <code>grind</code> context.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SplitSource.ematch">ematch<span class="decl_args">
<span class="fn">(<span class="fn">origin</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin">Origin</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Generated while instantiating a theorem using E-matching.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.ext">ext<span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Generated while instantiating an extensionality theorem with name <code>declName</code></p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.mbtc">mbtc<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Model-based theory combination equality coming from the i-th argument of applications <code>a</code> and <code>b</code></p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.beta">beta<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Beta-reduction.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.forallProp">forallProp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Forall-propagator.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.existsProp">existsProp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Exists-propagator.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.input">input : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Input goal</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitSource" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitSource"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L81-L81">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource">Lean.Meta.Grind.instInhabitedSplitSource</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default">Lean.Meta.Grind.instInhabitedSplitSource.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitSource.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L81-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default">Lean.Meta.Grind.instInhabitedSplitSource.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ematch">Lean.Meta.Grind.SplitSource.ematch</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSplitSource.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitSource.toMessageData"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L83-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span>.<span class="name">toMessageData</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a> → <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ematch">Lean.Meta.Grind.SplitSource.ematch</a> <span class="fn">origin</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;E-matching &quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn"><span class="fn">origin</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin.pp">pp</a></span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">Lean.Meta.Grind.SplitSource.ext</a> <span class="fn">declName</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Extensionality &quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">declName</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.beta">Lean.Meta.Grind.SplitSource.beta</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Beta-reduction of&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.forallProp">Lean.Meta.Grind.SplitSource.forallProp</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Forall propagation at&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.existsProp">Lean.Meta.Grind.SplitSource.existsProp</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Exists propagation at&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.input">Lean.Meta.Grind.SplitSource.input</a>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.MessageData.ofFormat">Lean.MessageData.ofFormat</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.format">Std.format</a>) <span class="fn">&quot;Initial goal&quot;</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitSource.toMessageData" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L92-L123">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Context for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.Context.mk"><li id="Lean.Meta.Grind.Context.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context">Simp.Context</a></div></li><li id="Lean.Meta.Grind.Context.simpMethods" class="structure_field"><div class="structure_field_info">simpMethods : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Methods">Simp.Methods</a></div></li><li id="Lean.Meta.Grind.Context.config" class="structure_field"><div class="structure_field_info">config : <a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config">Grind.Config</a></div></li><li id="Lean.Meta.Grind.Context.cheapCases" class="structure_field"><div class="structure_field_info">cheapCases : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></code> is <code>true</code>, <code>grind</code> only applies <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> to types that contain
at most one minor premise.
Recall that <code>grind</code> applies <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> when introducing types tagged with <code>[grind <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a> eager]</code>,
and at <code>Split.lean</code>
Remark: We add this option to implement the <code>lookahead</code> feature, we don't want to create several subgoals
when performing lookahead.</p></div></li><li id="Lean.Meta.Grind.Context.reportMVarIssue" class="structure_field"><div class="structure_field_info">reportMVarIssue : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.Grind.Context.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div><div class="structure_field_doc"><p>Current source of case-splits.</p></div></li><li id="Lean.Meta.Grind.Context.symPrios" class="structure_field"><div class="structure_field_info">symPrios : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities">SymbolPriorities</a></div><div class="structure_field_doc"><p>Symbol priorities for inferring E-matching patterns</p></div></li><li id="Lean.Meta.Grind.Context.trueExpr" class="structure_field"><div class="structure_field_info">trueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.falseExpr" class="structure_field"><div class="structure_field_info">falseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.natZExpr" class="structure_field"><div class="structure_field_info">natZExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.btrueExpr" class="structure_field"><div class="structure_field_info">btrueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.bfalseExpr" class="structure_field"><div class="structure_field_info">bfalseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.ordEqExpr" class="structure_field"><div class="structure_field_info">ordEqExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.intExpr" class="structure_field"><div class="structure_field_info">intExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTheoremCacheKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L125-L128">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence theorem cache.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrTheoremCacheKey.mk"><li id="Lean.Meta.Grind.CongrTheoremCacheKey.f" class="structure_field"><div class="structure_field_info">f : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CongrTheoremCacheKey.numArgs" class="structure_field"><div class="structure_field_info">numArgs : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrTheoremCacheKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L131-L132">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey">Lean.Meta.Grind.instBEqCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a>     <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L135-L136">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey">Lean.Meta.Grind.instHashableCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a>     <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">a</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.hashPtrExpr">Lean.Meta.Grind.hashPtrExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span>)</span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatchTheoremTrace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L138-L141">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.EMatchTheoremTrace.mk"><li id="Lean.Meta.Grind.EMatchTheoremTrace.origin" class="structure_field"><div class="structure_field_info">origin : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin">Origin</a></div></li><li id="Lean.Meta.Grind.EMatchTheoremTrace.kind" class="structure_field"><div class="structure_field_info">kind : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheoremKind">EMatchTheoremKind</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.EMatchTheoremTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqEMatchTheoremTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace">Lean.Meta.Grind.instBEqEMatchTheoremTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq">Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqEMatchTheoremTrace</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq">Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">{</a> <span class="fn">origin</span> := <span class="fn">a</span>, <span class="fn">kind</span> := <span class="fn">a_1</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">}</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">{</a> <span class="fn">origin</span> := <span class="fn">b</span>, <span class="fn">kind</span> := <span class="fn">b_1</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">}</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">a_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b_1</span>)</li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq">Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq</a> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instBEqEMatchTheoremTrace.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a> → <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash">Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">{</a> <span class="fn">origin</span> := <span class="fn">a</span>, <span class="fn">kind</span> := <span class="fn">a_1</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace.mk">}</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">0</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a</span>)</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a_1</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableEMatchTheoremTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableEMatchTheoremTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace">Lean.Meta.Grind.instHashableEMatchTheoremTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash">Lean.Meta.Grind.instHashableEMatchTheoremTrace.hash</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Trace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L143-L153">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Trace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>E-match theorems and case-splits performed by <code>grind</code>.
Note that it may contain elements that are not needed by the final proof.
For example, <code>grind</code> instantiated the theorem, but theorem instance was not actually used
in the proof.</p><ul class="structure_fields" id="Lean.Meta.Grind.Trace.mk"><li id="Lean.Meta.Grind.Trace.thms" class="structure_field"><div class="structure_field_info">thms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatchTheoremTrace">EMatchTheoremTrace</a></span></div></li><li id="Lean.Meta.Grind.Trace.eagerCases" class="structure_field"><div class="structure_field_info">eagerCases : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Grind.Trace.cases" class="structure_field"><div class="structure_field_info">cases : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Trace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L153-L153">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace">Trace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace">Lean.Meta.Grind.instInhabitedTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace.default">Lean.Meta.Grind.instInhabitedTrace.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedTrace.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L153-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTrace</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace">Trace</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTrace.default">Lean.Meta.Grind.instInhabitedTrace.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.mk">{</a> <span class="fn">thms</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">eagerCases</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">cases</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedTrace.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Counters"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L155-L162">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Counters.mk"><li id="Lean.Meta.Grind.Counters.thm" class="structure_field"><div class="structure_field_info">thm : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.Origin">Origin</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times E-match theorem has been instantiated.</p></div></li><li id="Lean.Meta.Grind.Counters.case" class="structure_field"><div class="structure_field_info">case : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code> has been performed on an inductive type/predicate</p></div></li><li id="Lean.Meta.Grind.Counters.apps" class="structure_field"><div class="structure_field_info">apps : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of applications per function symbol. This information is only collected if <code>set_option diagnostics true</code></p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Counters" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCounters"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters">Lean.Meta.Grind.instInhabitedCounters</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default">Lean.Meta.Grind.instInhabitedCounters.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCounters.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default">Lean.Meta.Grind.instInhabitedCounters.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">{</a> <span class="fn">thm</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">case</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">apps</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedCounters.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitDiagInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L166-L172">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitDiagInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split diagnostic information</p><ul class="structure_fields" id="Lean.Meta.Grind.SplitDiagInfo.mk"><li id="Lean.Meta.Grind.SplitDiagInfo.lctx" class="structure_field"><div class="structure_field_info">lctx : <a href="../../../.././Lean/LocalContext.html#Lean.LocalContext">LocalContext</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.c" class="structure_field"><div class="structure_field_info">c : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.gen" class="structure_field"><div class="structure_field_info">gen : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.numCases" class="structure_field"><div class="structure_field_info">numCases : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitDiagInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L174-L210">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>State for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.State.mk"><li id="Lean.Meta.Grind.State.scState" class="structure_field"><div class="structure_field_info">scState : <a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html#Lean.Meta.Grind.AlphaShareCommon.State">AlphaShareCommon.State</a></div><div class="structure_field_doc"><p><code>ShareCommon</code> (aka <code>Hash-consing</code>) state.</p></div></li><li id="Lean.Meta.Grind.State.congrThms" class="structure_field"><div class="structure_field_info">congrThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div><div class="structure_field_doc"><p>Congruence theorems generated so far. Recall that for constant symbols
we rely on the reserved name feature (i.e., <code>mkHCongrWithArityForConst?</code>).
Remark: we currently do not reuse congruence theorems</p></div></li><li id="Lean.Meta.Grind.State.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.State">Simp.State</a></div></li><li id="Lean.Meta.Grind.State.lastTag" class="structure_field"><div class="structure_field_info">lastTag : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>Used to generate trace messages of the for <code>[grind] working on &lt;tag&gt;</code>,
and implement the macro <code>trace_goal</code>.</p></div></li><li id="Lean.Meta.Grind.State.issues" class="structure_field"><div class="structure_field_info">issues : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a></span></div><div class="structure_field_doc"><p>Issues found during the proof search. These issues are reported to
users when <code>grind</code> fails.</p></div></li><li id="Lean.Meta.Grind.State.trace" class="structure_field"><div class="structure_field_info">trace : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace">Trace</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.trace">trace</a></code> for <code>grind?</code></p></div></li><li id="Lean.Meta.Grind.State.counters" class="structure_field"><div class="structure_field_info">counters : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></div><div class="structure_field_doc"><p>Performance counters</p></div></li><li id="Lean.Meta.Grind.State.splitDiags" class="structure_field"><div class="structure_field_info">splitDiags : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo">SplitDiagInfo</a></span></div><div class="structure_field_doc"><p>Split diagnostic information. This information is only collected when <code>set_option diagnostics true</code></p></div></li><li id="Lean.Meta.Grind.State.lawfulEqCmpMap" class="structure_field"><div class="structure_field_info">lawfulEqCmpMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from binary functions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to a theorem <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.thm">thm</a> : ∀ a b, <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a> a b = .<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a> → a = b</code>
if it implements the <code>LawfulEqCmp</code> type class.</p></div></li><li id="Lean.Meta.Grind.State.reflCmpMap" class="structure_field"><div class="structure_field_info">reflCmpMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from binary functions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to a theorem <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.thm">thm</a> : ∀ a, <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a> a a = .<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a></code>
if it implements the <code>ReflCmp</code> type class.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.MethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L213-L213">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">MethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRefPointed">Lean.Meta.Grind.MethodsRefPointed✝</a>.<a href="../../../.././Init/Prelude.html#NonemptyType.type">type</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.MethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.GrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L216-L216">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef</a>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a> <span class="fn">(<a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State">Lean.Meta.Grind.State</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mapGrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L218-L219">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM">Lean.Meta.Grind.mapGrindM</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#controlAt">controlAt</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a>
    <span class="fn">fun (<span class="fn">runInBase</span> : <span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">(<a href="../../../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">m</span> <span class="fn">β</span>)</span></span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">runInBase</span> <span class="fn">x</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mapGrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutReportingMVarIssues"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L221-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues">withoutReportingMVarIssues</a> x</code> executes <code>x</code> without reporting metavariables found during internalization.
See comment at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">Grind.Context.reportMVarIssue</a></code> for additional details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutReportingMVarIssues" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withSplitSource"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L228-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withSplitSource</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withSplitSource">withSplitSource</a> s x</code> executes <code>x</code> and uses <code>s</code> as the split source for any case-split
registered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withSplitSource" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L235-L237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config">Grind.Config</a></span></div></div><p>Returns the user-defined configuration options</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.config">config</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L239-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.trueExpr">trueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L243-L245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.falseExpr">falseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L247-L249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.btrueExpr">btrueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L251-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.bfalseExpr">bfalseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNatZeroExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L255-L257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code>0 : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></code> numeral.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr">Lean.Meta.Grind.getNatZeroExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.natZExpr">natZExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNatZeroExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getOrderingEqExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L259-L261">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getOrderingEqExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getOrderingEqExpr">Lean.Meta.Grind.getOrderingEqExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.ordEqExpr">ordEqExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getOrderingEqExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getIntExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L263-L265">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getIntExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getIntExpr">Lean.Meta.Grind.getIntExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.intExpr">intExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getIntExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.cheapCasesOnly"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L267-L268">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly">Lean.Meta.Grind.cheapCasesOnly</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.cheapCasesOnly" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportMVarInternalization"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L270-L271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization">Lean.Meta.Grind.reportMVarInternalization</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">reportMVarIssue</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportMVarInternalization" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getSymbolPriorities"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L273-L275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getSymbolPriorities"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getSymbolPriorities</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities">SymbolPriorities</a></span></div></div><p>Returns symbol priorities for inferring E-matching patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getSymbolPriorities">Lean.Meta.Grind.getSymbolPriorities</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.symPrios">symPrios</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getSymbolPriorities" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isMatchEqLikeDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L277-L281">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>declName</code> is the name of a <code>match</code> equation or a <code>match</code> congruence equation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isMatchEqLikeDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L295-L301">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eager</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveAppOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L303-L306">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveAppOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveAppOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveAppOf">Lean.Meta.Grind.saveAppOf</a> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/CoreM.html#Lean.isDiagnosticsEnabled">Lean.isDiagnosticsEnabled</a></span>
  <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">__do_lift</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveAppOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveSplitDiagInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L308-L311">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveSplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveSplitDiagInfo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">gen </span><span class="fn">numCases</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveSplitDiagInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L313-L314">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#MonadReader.read">read</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMaxGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L316-L318">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns maximum term generation that is considered during ematching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration">Lean.Meta.Grind.getMaxGeneration</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.gen">gen</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMaxGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.abstractNestedProofs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L320-L324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Abstracts nested proofs in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. This is a preprocessing step performed before internalization.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs">Lean.Meta.Grind.abstractNestedProofs</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/AbstractNestedProofs.html#Lean.Meta.abstractNestedProofs">Lean.Meta.abstractNestedProofs</a> <span class="fn">e</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.abstractNestedProofs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.shareCommon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L326-L334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Applies hash-consing to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. Recall that all expressions in a <code>grind</code> goal have
been hash-consed. We perform this step before we internalize expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.shareCommon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L336-L338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr">Lean.Meta.Grind.isTrueExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L340-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr">Lean.Meta.Grind.isFalseExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkHCongrWithArity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L344-L357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">numArgs</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div></div><p>Creates a congruence theorem for a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-applications with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></code> arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkHCongrWithArity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportIssue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L359-L366">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportIssue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.doElemReportIssue!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L374-L375">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.doElemReportIssue!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverTerms"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L377-L392">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Each E-node may have &quot;solver terms&quot; attached to them.
Each term is an element of the equivalence class that the
solver cares about. Each solver is responsible for marking the terms they care about.
The <code>grind</code> core propagates equalities and disequalities to the theory solvers
using these &quot;marked&quot; terms. The root of the equivalence class
contains a list of representatives sorted by solver id. Note that many E-nodes
do not have any solver terms attached to them.</p><p>&quot;Solver terms&quot; are referenced as &quot;theory variables&quot; in the SMT literature.
The SMT solver Z3 uses a similar representation.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SolverTerms.nil">nil : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></li><li class="constructor" id="Lean.Meta.Grind.SolverTerms.next">next<span class="decl_args">
<span class="fn">(<span class="fn">solverId</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rest</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.SolverTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverTerms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L392-L392">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms">Lean.Meta.Grind.instInhabitedSolverTerms</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default">Lean.Meta.Grind.instInhabitedSolverTerms.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverTerms.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L392-L392">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default">Lean.Meta.Grind.instInhabitedSolverTerms.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms.nil">Lean.Meta.Grind.SolverTerms.nil</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSolverTerms.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprSolverTerms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L392-L392">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms">Lean.Meta.Grind.instReprSolverTerms</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms.repr">Lean.Meta.Grind.instReprSolverTerms.repr</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprSolverTerms.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L392-L392">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a> → <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../../.././Init/Data/Format/Basic.html#Std.Format">Format</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instReprSolverTerms.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L394-L440">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Stores information for a node in the E-graph.
Each internalized expression <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> associated with it.</p><ul class="structure_fields" id="Lean.Meta.Grind.ENode.mk"><li id="Lean.Meta.Grind.ENode.self" class="structure_field"><div class="structure_field_info">self : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Node represented by this ENode.</p></div></li><li id="Lean.Meta.Grind.ENode.next" class="structure_field"><div class="structure_field_info">next : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Next element in the equivalence class.</p></div></li><li id="Lean.Meta.Grind.ENode.root" class="structure_field"><div class="structure_field_info">root : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Root (aka canonical representative) of the equivalence class</p></div></li><li id="Lean.Meta.Grind.ENode.congr" class="structure_field"><div class="structure_field_info">congr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Init/Prelude.html#congr">congr</a></code> is the term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is congruent to.
We say <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is the congruence class root if <code>isSameExpr <a href="../../../.././Init/Prelude.html#congr">congr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code>.
This field is initialized to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> even if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is not an application.</p></div></li><li id="Lean.Meta.Grind.ENode.target?" class="structure_field"><div class="structure_field_info">target? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>When <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> was added to this equivalence class because of an equality <code>h : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> = target</code>,
then we store <code>target</code> here, and <code>h</code> at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.proof?">proof?</a></code>.</p></div></li><li id="Lean.Meta.Grind.ENode.proof?" class="structure_field"><div class="structure_field_info">proof? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.ENode.flipped" class="structure_field"><div class="structure_field_info">flipped : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Proof has been flipped.</p></div></li><li id="Lean.Meta.Grind.ENode.size" class="structure_field"><div class="structure_field_info">size : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of elements in the equivalence class, this field is meaningless if node is not the root.</p></div></li><li id="Lean.Meta.Grind.ENode.interpreted" class="structure_field"><div class="structure_field_info">interpreted : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.interpreted">interpreted</a> := true</code> if node should be viewed as an abstract value.</p></div></li><li id="Lean.Meta.Grind.ENode.ctor" class="structure_field"><div class="structure_field_info">ctor : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.ctor">ctor</a> := true</code> if the head symbol is a constructor application.</p></div></li><li id="Lean.Meta.Grind.ENode.hasLambdas" class="structure_field"><div class="structure_field_info">hasLambdas : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.hasLambdas">hasLambdas</a> := true</code> if the equivalence class contains lambda expressions.</p></div></li><li id="Lean.Meta.Grind.ENode.heqProofs" class="structure_field"><div class="structure_field_info">heqProofs : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.heqProofs">heqProofs</a> := true</code>, then some proofs in the equivalence class are based
on heterogeneous equality.</p></div></li><li id="Lean.Meta.Grind.ENode.idx" class="structure_field"><div class="structure_field_info">idx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Unique index used for pretty printing and debugging purposes.</p></div></li><li id="Lean.Meta.Grind.ENode.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The generation in which this enode was created.</p></div></li><li id="Lean.Meta.Grind.ENode.mt" class="structure_field"><div class="structure_field_info">mt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Modification time</p></div></li><li id="Lean.Meta.Grind.ENode.sTerms" class="structure_field"><div class="structure_field_info">sTerms : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></div><div class="structure_field_doc"><p>Solver terms attached to this E-node.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.ENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode">Lean.Meta.Grind.instInhabitedENode</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode.default">Lean.Meta.Grind.instInhabitedENode.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENode.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedENode.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode">Lean.Meta.Grind.instReprENode</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode.repr">Lean.Meta.Grind.instReprENode.repr</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprENode.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L440-L440">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../../.././Init/Data/Format/Basic.html#Std.Format">Format</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instReprENode.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L442-L443">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot">isRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L445-L446">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.congr">congr</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewFact"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L448-L451">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New equalities and facts to be processed.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.NewFact.eq">eq<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li><li class="constructor" id="Lean.Meta.Grind.NewFact.fact">fact<span class="decl_args">
<span class="fn">(<span class="fn">prop </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENodeMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L454-L454">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">Lean.Meta.Grind.ENodeMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">Lean.Meta.Grind.ExprPtr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">Lean.Meta.Grind.ENode</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENodeMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENodeMap"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L455-L456">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENodeMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap">Lean.Meta.Grind.instInhabitedENodeMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap._private_1">Lean.Meta.Grind.instInhabitedENodeMap._private_1</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L458-L463">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodes</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence table.
We need access to the <code>enodes</code> to be able to retrieve the equivalence class roots.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrKey.mk"><li id="Lean.Meta.Grind.CongrKey.e" class="structure_field"><div class="structure_field_info">e : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L532-L533">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey">Lean.Meta.Grind.instHashableCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey._private_1">Lean.Meta.Grind.instHashableCongrKey._private_1</a> <span class="fn">k</span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L535-L536">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey">Lean.Meta.Grind.instBEqCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">k1</span> <span class="fn">k2</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey._private_1">Lean.Meta.Grind.instBEqCongrKey._private_1</a> <span class="fn">k1</span> <span class="fn">k2</span></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L538-L538">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">Lean.Meta.Grind.CongrTable</a> <span class="fn">enodeMap</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.CongrTable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L541-L541">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">Lean.Meta.Grind.ParentSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr.quickComp">Lean.Expr.quickComp</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L542-L542">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">Lean.Meta.Grind.ParentMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">Lean.Meta.Grind.ExprPtr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">Lean.Meta.Grind.ParentSet</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstance"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L544-L553">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The E-matching module instantiates theorems using the <code>EMatchTheorem <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> and a (partial) assignment.
We want to avoid instantiating the same theorem with the same assignment more than once.
Therefore, we store the (pre-)instance information in set.
Recall that the proofs of activated theorems have been hash-consed.
The assignment contains internalized expressions, which have also been hash-consed.</p><ul class="structure_fields" id="Lean.Meta.Grind.PreInstance.mk"><li id="Lean.Meta.Grind.PreInstance.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.PreInstance.assignment" class="structure_field"><div class="structure_field_info">assignment : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.PreInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashablePreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L555-L560">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqPreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L562-L568">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstanceSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L570-L570">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">Lean.Meta.Grind.PreInstanceSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">Lean.Meta.Grind.PreInstance</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.PreInstanceSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewRawFact"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L572-L579">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New raw fact to be preprocessed, and then asserted.</p><ul class="structure_fields" id="Lean.Meta.Grind.NewRawFact.mk"><li id="Lean.Meta.Grind.NewRawFact.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.prop" class="structure_field"><div class="structure_field_info">prop : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.NewRawFact.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.splitSource">splitSource</a></code> to use when internalizing this fact.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedNewRawFact.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L579-L579">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default">Lean.Meta.Grind.instInhabitedNewRawFact.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">{</a> <span class="fn">proof</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">prop</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">generation</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">splitSource</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedNewRawFact.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedNewRawFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L579-L579">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact">Lean.Meta.Grind.instInhabitedNewRawFact</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default">Lean.Meta.Grind.instInhabitedNewRawFact.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L581-L586">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Canonicalizer state. See <code>Canon.lean</code> for additional details.</p><ul class="structure_fields" id="Lean.Meta.Grind.Canon.State.mk"><li id="Lean.Meta.Grind.Canon.State.argMap" class="structure_field"><div class="structure_field_info">argMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>))</span></span></div></li><li id="Lean.Meta.Grind.Canon.State.canon" class="structure_field"><div class="structure_field_info">canon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Canon.State.proofCanon" class="structure_field"><div class="structure_field_info">proofCanon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Canon.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L586-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default">Lean.Meta.Grind.Canon.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">{</a> <span class="fn">argMap</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">canon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">proofCanon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Canon.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L586-L586">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState">Lean.Meta.Grind.Canon.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default">Lean.Meta.Grind.Canon.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CaseTrace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L588-L594">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Trace information for a case split.</p><ul class="structure_fields" id="Lean.Meta.Grind.CaseTrace.mk"><li id="Lean.Meta.Grind.CaseTrace.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CaseTrace.i" class="structure_field"><div class="structure_field_info">i : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CaseTrace.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CaseTrace.source" class="structure_field"><div class="structure_field_info">source : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CaseTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCaseTrace.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L594-L594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default">Lean.Meta.Grind.instInhabitedCaseTrace.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">{</a> <span class="fn">expr</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">i</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">num</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">source</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedCaseTrace.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCaseTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L594-L594">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace">Lean.Meta.Grind.instInhabitedCaseTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default">Lean.Meta.Grind.instInhabitedCaseTrace.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L596-L619">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>E-matching related fields for the <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.EMatch.State.mk"><li id="Lean.Meta.Grind.EMatch.State.thmMap" class="structure_field"><div class="structure_field_info">thmMap : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems">EMatchTheorems</a></div><div class="structure_field_doc"><p>Inactive global theorems. As we internalize terms, we activate theorems as we find their symbols.
Local theorem provided by users are added directly into <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.newThms">newThms</a></code>.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.gmt" class="structure_field"><div class="structure_field_info">gmt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Goal modification time.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.thms" class="structure_field"><div class="structure_field_info">thms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have performed ematching at least once.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.newThms" class="structure_field"><div class="structure_field_info">newThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have not performed any round of ematching yet.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.numInstances" class="structure_field"><div class="structure_field_info">numInstances : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of theorem instances generated so far</p></div></li><li id="Lean.Meta.Grind.EMatch.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of E-matching rounds performed in this goal since the last case-split.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.preInstances" class="structure_field"><div class="structure_field_info">preInstances : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">PreInstanceSet</a></div><div class="structure_field_doc"><p>(pre-)instances found so far. It includes instances that failed to be instantiated.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.nextThmIdx" class="structure_field"><div class="structure_field_info">nextThmIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next local E-match theorem idx.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.matchEqNames" class="structure_field"><div class="structure_field_info">matchEqNames : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div><div class="structure_field_doc"><p><code>match</code> auxiliary functions whose equations have already been created and activated.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.EMatch.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L619-L619">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.EMatch.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L619-L619">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState">Lean.Meta.Grind.EMatch.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState.default">Lean.Meta.Grind.EMatch.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L621-L635">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split information.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SplitInfo.default">default<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> may be an inductive predicate, <code>match</code>-expression, <code>if</code>-expression, implication, etc.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.imp">imp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isForall">isForall</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is an implication and we want to split on its antecedent.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.arg">arg<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Given applications <code>a</code> and <code>b</code>, case-split on whether the corresponding
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a></code>-th arguments are equal or not. The split is only performed if all other
arguments are already known to be equal or are also tagged as split candidates.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L635-L635">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo">Lean.Meta.Grind.instInhabitedSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default">Lean.Meta.Grind.instInhabitedSplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L635-L635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default">Lean.Meta.Grind.instInhabitedSplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSplitInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L637-L640">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L642-L643">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo">Lean.Meta.Grind.instHashableSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">Lean.Meta.Grind.SplitInfo.hash</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L645-L649">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₁</span> <span class="fn">b₁</span> <span class="fn">i₁</span> <span class="fn">eq₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₂</span> <span class="fn">b₂</span> <span class="fn">i₂</span> <span class="fn">eq₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   (<span class="fn">a₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">i₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">i₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">eq₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">eq₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L651-L652">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo">Lean.Meta.Grind.instBEqSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">Lean.Meta.Grind.SplitInfo.beq</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.getExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L654-L657">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.forallDomain">forallDomain</a></span> <span class="fn">h</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.getExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.source"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L659-L662">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">source</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.source" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L664-L670">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a_1</span> <span class="fn">b_1</span> <span class="fn">i_1</span> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.lt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitArg"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L672-L676">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Argument <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">arg</a> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.type">type</a></code> of an application <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.app">app</a></code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></code>.</p><ul class="structure_fields" id="Lean.Meta.Grind.SplitArg.mk"><li id="Lean.Meta.Grind.SplitArg.arg" class="structure_field"><div class="structure_field_info">arg : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.type" class="structure_field"><div class="structure_field_info">type : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.app" class="structure_field"><div class="structure_field_info">app : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L678-L713">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case splitting related fields for the <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Split.State.mk"><li id="Lean.Meta.Grind.Split.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of splits performed to get to this goal.</p></div></li><li id="Lean.Meta.Grind.Split.State.casesTypes" class="structure_field"><div class="structure_field_info">casesTypes : <a href="../../../.././Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.CasesTypes">CasesTypes</a></div><div class="structure_field_doc"><p>Inductive datatypes marked for case-splitting</p></div></li><li id="Lean.Meta.Grind.Split.State.candidates" class="structure_field"><div class="structure_field_info">candidates : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-split candidates.</p></div></li><li id="Lean.Meta.Grind.Split.State.added" class="structure_field"><div class="structure_field_info">added : <span class="fn"><a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet">Std.HashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-splits that have been inserted at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> at some point.</p></div></li><li id="Lean.Meta.Grind.Split.State.resolved" class="structure_field"><div class="structure_field_info">resolved : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a></span></div><div class="structure_field_doc"><p>Case-splits that have already been performed, or that do not have to be performed anymore.</p></div></li><li id="Lean.Meta.Grind.Split.State.trace" class="structure_field"><div class="structure_field_info">trace : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div><div class="structure_field_doc"><p>Sequence of cases steps that generated this goal. We only use this information for diagnostics.
Remark: <code>casesTrace.length ≥ numSplits</code> because we don't increase the counter for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Trace.cases">cases</a></code>
applications that generated only 1 subgoal.</p></div></li><li id="Lean.Meta.Grind.Split.State.lookaheads" class="structure_field"><div class="structure_field_info">lookaheads : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Lookahead &quot;case-splits&quot;.</p></div></li><li id="Lean.Meta.Grind.Split.State.argPosMap" class="structure_field"><div class="structure_field_info">argPosMap : <span class="fn"><a href="../../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span></div><div class="structure_field_doc"><p>A mapping <code>(a, b) ↦ is</code> s.t. for each <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">SplitInfo.arg</a> a b <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a></code>
in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> or <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.lookaheads">lookaheads</a></code> we have <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a> ∈ is</code>.
We use this information to decide whether the split/lookahead is &quot;ready&quot;
to be tried or not.</p></div></li><li id="Lean.Meta.Grind.Split.State.argsAt" class="structure_field"><div class="structure_field_info">argsAt : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg">SplitArg</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from pairs <code>(f, i)</code> to a list of arguments.
Each argument occurs as the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.i">i</a></code>-th of an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-application.
We use this information to add splits/lookaheads for
triggering extensionality theorems and model-based theory combination.
See <code>addSplitCandidatesForExt</code>.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Split.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L713-L713">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Split.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L713-L713">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState">Lean.Meta.Grind.Split.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState.default">Lean.Meta.Grind.Split.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L715-L719">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Clean name generator.</p><ul class="structure_fields" id="Lean.Meta.Grind.Clean.State.mk"><li id="Lean.Meta.Grind.Clean.State.used" class="structure_field"><div class="structure_field_info">used : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Grind.Clean.State.next" class="structure_field"><div class="structure_field_info">next : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Clean.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L719-L719">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState">Lean.Meta.Grind.Clean.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default">Lean.Meta.Grind.Clean.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L719-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default">Lean.Meta.Grind.Clean.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">{</a> <span class="fn">used</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">next</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Clean.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L721-L727">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Cache for <code><a href="../../../.././Init/Prelude.html#Unit">Unit</a></code>-like types. It maps the type to its element.
We say a type is <code><a href="../../../.././Init/Prelude.html#Unit">Unit</a></code>-like if it is a subsingleton and is inhabited.</p><ul class="structure_fields" id="Lean.Meta.Grind.UnitLike.State.mk"><li id="Lean.Meta.Grind.UnitLike.State.map" class="structure_field"><div class="structure_field_info">map : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.UnitLike.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L727-L727">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState">Lean.Meta.Grind.UnitLike.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default">Lean.Meta.Grind.UnitLike.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L727-L727">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default">Lean.Meta.Grind.UnitLike.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State.mk">{</a> <span class="fn">map</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.UnitLike.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L729-L763">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The <code>grind</code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Goal.mk"><li id="Lean.Meta.Grind.Goal.mvarId" class="structure_field"><div class="structure_field_info">mvarId : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></div></li><li id="Lean.Meta.Grind.Goal.canon" class="structure_field"><div class="structure_field_info">canon : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">Canon.State</a></div></li><li id="Lean.Meta.Grind.Goal.enodeMap" class="structure_field"><div class="structure_field_info">enodeMap : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a></div></li><li id="Lean.Meta.Grind.Goal.exprs" class="structure_field"><div class="structure_field_info">exprs : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Goal.parents" class="structure_field"><div class="structure_field_info">parents : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">ParentMap</a></div></li><li id="Lean.Meta.Grind.Goal.congrTable" class="structure_field"><div class="structure_field_info">congrTable : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">CongrTable</a> <span class="fn"><span class="fn">self</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span></span></div></li><li id="Lean.Meta.Grind.Goal.appMap" class="structure_field"><div class="structure_field_info">appMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>A mapping from each function application index (<code>HeadIndex</code>) to a list of applications with that index.
Recall that the <code>HeadIndex</code> for a constant is its constant name, and for a free variable,
it is its unique id.</p></div></li><li id="Lean.Meta.Grind.Goal.newFacts" class="structure_field"><div class="structure_field_info">newFacts : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></span></div><div class="structure_field_doc"><p>Equations and propositions to be processed.</p></div></li><li id="Lean.Meta.Grind.Goal.inconsistent" class="structure_field"><div class="structure_field_info">inconsistent : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a> := true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code>s for <code><a href="../../../.././Init/Prelude.html#True">True</a></code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p></div></li><li id="Lean.Meta.Grind.Goal.nextIdx" class="structure_field"><div class="structure_field_info">nextIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next unique index for creating ENodes</p></div></li><li id="Lean.Meta.Grind.Goal.newRawFacts" class="structure_field"><div class="structure_field_info">newRawFacts : <span class="fn"><a href="../../../.././Init/Data/Queue.html#Std.Queue">Std.Queue</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div><div class="structure_field_doc"><p>new facts to be preprocessed and then asserted.</p></div></li><li id="Lean.Meta.Grind.Goal.facts" class="structure_field"><div class="structure_field_info">facts : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Asserted facts</p></div></li><li id="Lean.Meta.Grind.Goal.extThms" class="structure_field"><div class="structure_field_info">extThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div><div class="structure_field_doc"><p>Cached extensionality theorems for types.</p></div></li><li id="Lean.Meta.Grind.Goal.ematch" class="structure_field"><div class="structure_field_info">ematch : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">EMatch.State</a></div><div class="structure_field_doc"><p>State of the E-matching module.</p></div></li><li id="Lean.Meta.Grind.Goal.split" class="structure_field"><div class="structure_field_info">split : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">Split.State</a></div><div class="structure_field_doc"><p>State of the case-splitting module.</p></div></li><li id="Lean.Meta.Grind.Goal.clean" class="structure_field"><div class="structure_field_info">clean : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">Clean.State</a></div><div class="structure_field_doc"><p>State of the clean name generator.</p></div></li><li id="Lean.Meta.Grind.Goal.sstates" class="structure_field"><div class="structure_field_info">sstates : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a></span></div><div class="structure_field_doc"><p>Solver states.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Goal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L763-L763">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal">Lean.Meta.Grind.instInhabitedGoal</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal.default">Lean.Meta.Grind.instInhabitedGoal.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoal.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L763-L763">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedGoal.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.hasSameRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L765-L766">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot">hasSameRoot</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.hasSameRoot">Lean.Meta.Grind.hasSameRoot✝</a> <span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.hasSameRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.isCongruent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L768-L769">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent">isCongruent</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isCongruent">Lean.Meta.Grind.isCongruent✝</a> <span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.isCongruent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.admit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L771-L772">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit">admit</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Tactic/Util.html#Lean.MVarId.admit">admit</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.admit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L774-L774">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.runCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L776-L777">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'.run">StateRefT'.run</a> <span class="fn">x</span> <span class="fn">goal</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.runCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L779-L780">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run">Lean.Meta.Grind.GoalM.run</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L782-L783">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'">Lean.Meta.Grind.GoalM.run'</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">x</span> *&gt; <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>)</span>.<a href="../../../.././Init/Control/StateRef.html#StateRefT'.run'">run'</a></span> <span class="fn">goal</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.updateLastTag"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L785-L790">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.updateLastTag" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.«doElemTrace_goal[_]__»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L796-L802">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Macro similar to <code>trace[...]</code>, but it includes the trace message <code>trace[grind] &quot;working on &lt;current goal&gt;&quot;</code>
if the tag has changed since the last trace message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.«doElemTrace_goal[_]__»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L804-L813">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">assignment</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>A helper function used to mark a theorem instance found by the E-matching module.
It returns <code>true</code> if it is a new instance and <code>false</code> otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addNewRawFact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L815-L822">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new fact <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.prop">prop</a></code> with proof <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to the queue for preprocessing and the assertion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addNewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L824-L828">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new theorem instance produced using E-matching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxInstancesExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L830-L832">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of instances has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded">Lean.Meta.Grind.checkMaxInstancesExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.numInstances">numInstances</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.instances">instances</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxInstancesExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L834-L836">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of case-splits has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit">Lean.Meta.Grind.checkMaxCaseSplit</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.splits">splits</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxEmatchExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L838-L840">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of E-matching rounds has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded">Lean.Meta.Grind.checkMaxEmatchExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Tactics.html#Lean.Grind.Config.ematch">ematch</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxEmatchExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L842-L847">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L849-L851">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.throwNonInternalizedExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L853-L854">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr">Lean.Meta.Grind.throwNonInternalizedExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Exception.html#Lean.throwError">Lean.throwError</a>
    (<span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;internal `grind` error, term has not been internalized&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a>       <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.throwNonInternalizedExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L856-L860">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span> with
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">n</span></span>
  | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr">Lean.Meta.Grind.throwNonInternalizedExpr</a> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L862-L864">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L866-L869">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns the generation of the given term. Is assumes it has been internalized</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration">Lean.Meta.Grind.getGeneration</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.generation">generation</a></span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">0</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L871-L873">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#True">True</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue">Lean.Meta.Grind.isEqTrue</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L875-L877">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse">Lean.Meta.Grind.isEqFalse</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L879-L881">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L883-L885">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L887-L894">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L896-L899">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot">Lean.Meta.Grind.isRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">e</span>)</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L901-L904">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L906-L908">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?">Lean.Meta.Grind.getRoot?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L910-L912">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L914-L916">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L918-L920">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L922-L925">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if it is in an equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?">Lean.Meta.Grind.getRootENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L927-L933">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>
if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized in the given goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?">getNext?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L935-L937">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L939-L941">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext">Lean.Meta.Grind.getNext</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.alreadyInternalized"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L943-L945">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized">Lean.Meta.Grind.alreadyInternalized</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.contains">Lean.PersistentHashMap.contains</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.alreadyInternalized" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L947-L949">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.target?">target?</a></span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L951-L952">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?">Lean.Meta.Grind.getTarget?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L954-L971">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>If <code>isHEq</code> is <code>false</code>, it pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.
Otherwise, it pushes <code>lhs ≍ rhs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasSameType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L973-L975">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if <code>a</code> and <code>b</code> have the same type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">a</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">b</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">__do_lift</span> <span class="fn">__do_lift_1</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasSameType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L977-L981">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L983-L985">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L987-L989">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>lhs ≍ rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq">Lean.Meta.Grind.pushHEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L991-L993">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue">Lean.Meta.Grind.pushEqTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L995-L997">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse">Lean.Meta.Grind.pushEqFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L999-L1001">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue">Lean.Meta.Grind.pushEqBoolTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1003-L1005">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse">Lean.Meta.Grind.pushEqBoolFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.registerParent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1007-L1014">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parent </span><span class="fn">child</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Records that <code>parent</code> is a parent of <code>child</code>. This function actually stores the
information in the root (aka canonical representative) of <code>child</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.registerParent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getParents"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1016-L1023">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></span></div></div><p>Returns the set of expressions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a child of, or an expression in
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class is a child of.
The information is only up to date if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root (aka canonical representative) of the equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents">Lean.Meta.Grind.getParents</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">parents</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">parents</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getParents" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.resetParentsOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1025-L1029">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Removes the entry <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> ↦ <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code> from the parent map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.resetParentsOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.copyParentsTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1031-L1039">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">root</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Copy <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code> to the parents of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code>.
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code> must be the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.copyParentsTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENodeCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1041-L1056">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">interpreted </span><span class="fn">ctor</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENodeCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1058-L1066">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Creates an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if one does not already exist.
This method assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been hash-consed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.setENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1068-L1072">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.setENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1074-L1078">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">α</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if type of <code>t</code> is definitionally equal to <code>α</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType">Lean.Meta.Grind.hasType</a> <span class="fn">t</span> <span class="fn">α</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">t</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">__do_lift</span> <span class="fn">α</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachDiseq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1080-L1096">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>For each equality <code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></code>, executes <code>k b <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> IF</p><ul>
<li><code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> is equal to <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, and</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachDiseq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1098-L1100">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> is <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root of its congruence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot">Lean.Meta.Grind.isCongrRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getCongrRoot"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1102-L1106">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root of the congruence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p></div></div><div class="decl" id="Lean.Meta.Grind.isInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1108-L1110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if the goal is inconsistent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent">Lean.Meta.Grind.isInconsistent</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1112-L1118">source</a></div><div class="attributes">@[extern lean_grind_mk_eq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class, and have the same type.</p></div></div><div class="decl" id="Lean.Meta.Grind.mkHEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1120-L1126">source</a></div><div class="attributes">@[extern lean_grind_mk_heq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a ≍ b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p></div></div><div class="decl" id="Lean.Meta.Grind.internalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1129-L1130">source</a></div><div class="attributes">@[extern lean_grind_internalize]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> := <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.processNewFacts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1133-L1134">source</a></div><div class="attributes">@[extern lean_grind_process_new_facts]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.mkEqHEqProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1136-L1144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code> if they have the same type. Otherwise, returns a proof of <code>a ≍ b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof">Lean.Meta.Grind.mkEqHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span>
  <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">__do_lift</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof">Lean.Meta.Grind.mkHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqHEqProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1146-L1151">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#True">True</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof">Lean.Meta.Grind.mkEqTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1153-L1158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof">Lean.Meta.Grind.mkEqFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1160-L1165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof">Lean.Meta.Grind.mkEqBoolTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1167-L1172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof">Lean.Meta.Grind.mkEqBoolFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1174-L1178">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks current goal as inconsistent without assigning <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.assignFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1180-L1189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Assign the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.
If type of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> is not <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, then use <code><a href="../../../.././Init/Prelude.html#False.elim">False.elim</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.assignFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.closeGoal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1191-L1199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Closes the current goal using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code> and
marks it as inconsistent if it is not already marked so.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.closeGoal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExprs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1201-L1203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all enodes in the goal</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs">Lean.Meta.Grind.getExprs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.exprs">exprs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExprs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.traverseEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1205-L1212">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Executes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to each term in the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.traverseEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.foldEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1214-L1224">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Folds using <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> and <code>init</code> over the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.foldEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1226-L1229">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.filterENodes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1231-L1236">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.filterENodes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachEqcRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1238-L1242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachEqcRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Propagator"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1244-L1244">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Lean.Meta.Grind.Propagator</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Propagator" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Fallback"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1245-L1245">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Fallback</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback">Lean.Meta.Grind.Fallback</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Fallback" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1247-L1251">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Methods.mk"><li id="Lean.Meta.Grind.Methods.propagateUp" class="structure_field"><div class="structure_field_info">propagateUp : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.propagateDown" class="structure_field"><div class="structure_field_info">propagateDown : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.fallback" class="structure_field"><div class="structure_field_info">fallback : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Fallback">Fallback</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1251-L1251">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods">Lean.Meta.Grind.instInhabitedMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default">Lean.Meta.Grind.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedMethods.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1251-L1251">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default">Lean.Meta.Grind.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">{</a> <span class="fn">propagateUp</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">propagateDown</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">fallback</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedMethods.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods.toMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1253-L1254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef">toMethodsRef</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3">Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3✝</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Methods.toMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1259-L1260">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef.toMethods">Lean.Meta.Grind.MethodsRef.toMethods✝</a> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateUp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1262-L1263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp">Lean.Meta.Grind.propagateUp</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateUp">propagateUp</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateUp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateDown"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1265-L1266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown">Lean.Meta.Grind.propagateDown</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateDown">propagateDown</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateDown" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.applyFallback"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1268-L1270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.applyFallback"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">applyFallback</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.applyFallback">Lean.Meta.Grind.applyFallback</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  have fallback : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span> := <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.fallback">fallback</a></span>
  <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.applyFallback" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1272-L1276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getGeneration</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getGeneration">getGeneration</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span> with
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.generation">generation</a></span>
  | <span class="fn">x</span> =&gt; <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1278-L1295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1297-L1299">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc">Lean.Meta.Grind.getEqc</a> <span class="fn">e</span> <span class="fn">sort</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc">getEqc</a></span> <span class="fn">e</span> <span class="fn">sort</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1301-L1311">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1313-L1315">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs">Lean.Meta.Grind.getEqcs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs">getEqcs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isKnownCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1317-L1323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>s</code> has been already added to the case-split list at one point.
Remark: this function returns <code>true</code> even if the split has already been resolved
and is not in the list anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit">Lean.Meta.Grind.isKnownCaseSplit</a> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.added">added</a></span>.<a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet.contains">contains</a></span> <span class="fn">s</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isKnownCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isResolvedCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1325-L1327">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a case-split that does not need to be performed anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit">Lean.Meta.Grind.isResolvedCaseSplit</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PersistentHashSet.contains">Lean.PersistentHashSet.contains</a> <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.resolved">resolved</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isResolvedCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markCaseSplitAsResolved"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1329-L1337">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a case-split that does not need to be performed anymore.
Remark: we currently use this feature to disable <code>match</code>-case-splits.
Remark: we also use this feature to record the case-splits that have already been performed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markCaseSplitAsResolved" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addSplitCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1347-L1355">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Inserts <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> into the list of case-split candidates if it was not inserted before.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addSplitCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExtTheorems"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1357-L1372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div></div><p>Returns extensionality theorems for the given type if available.
If <code>Config.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code> is <code>false</code>, the result is <code>#[]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExtTheorems" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addLookaheadCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1374-L1378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a new lookahead candidate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addLookaheadCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutModifyingState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1380-L1390">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Helper function for executing <code>x</code> with a fresh <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.newFacts">newFacts</a></code> and without modifying
the goal state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutModifyingState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.canon"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1392-L1394">source</a></div><div class="attributes">@[extern lean_grind_canon]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.canon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">canon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Canonicalizes nested types, type formers, and instances in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p></div></div><div class="mod_doc"><p>Solver Extensions</p></div><div class="decl" id="Lean.Meta.Grind.SolverExtension"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1400-L1413">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Solver extension, can only be generated by <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerSolverExtension">registerSolverExtension</a></code> that allocates a unique index
for this extension into each goal's extension state's array.</p><ul class="structure_fields" id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.mk"><li id="Lean.Meta.Grind.SolverExtension.id" class="structure_field"><div class="structure_field_info">id : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SolverExtension.mkInitial" class="structure_field"><div class="structure_field_info">mkInitial : <span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.internalize" class="structure_field"><div class="structure_field_info">internalize : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>) → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.newEq" class="structure_field"><div class="structure_field_info">newEq : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.newDiseq" class="structure_field"><div class="structure_field_info">newDiseq : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.mbtc" class="structure_field"><div class="structure_field_info">mbtc : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li id="Lean.Meta.Grind.SolverExtension.check" class="structure_field"><div class="structure_field_info">check : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li id="Lean.Meta.Grind.SolverExtension.checkInv" class="structure_field"><div class="structure_field_info">checkInv : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SolverExtension" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtension.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1413-L1413">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span>.<span class="name">default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">a✝</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSolverExtension.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtension"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1413-L1413">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">a✝</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension">Lean.Meta.Grind.instInhabitedSolverExtension</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension.default">Lean.Meta.Grind.instInhabitedSolverExtension.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.registerSolverExtension"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1417-L1437">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerSolverExtension</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mkInitial</span> : <span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span>)</span></span></div></div><p>Registers a new solver extension for <code>grind</code>.
Solver extensions can only be registered during initialization.
Reason: We do not use any synchronization primitive to access <code>solverExtensionsRef</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.registerSolverExtension" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.setMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1439-L1457">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.setMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">setMethods</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">internalize</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">newEq </span><span class="fn">newDiseq</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mbtc </span><span class="fn">check</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">checkInv</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Sets methods/handlers for solver extension <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code>.
Solver extension methods can only be registered during initialization.
Reason: We do not use any synchronization primitive to access <code>solverExtensionsRef</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.setMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mkInitialStates"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1459-L1462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mkInitialStates"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkInitialStates</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a>)</span></span></div></div><p>Returns initial state for registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mkInitialStates" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoalM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1464-L1465">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoalM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">σ</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoalM">Lean.Meta.Grind.instInhabitedGoalM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../../.././Lean/Exception.html#Lean.throwError">Lean.throwError</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;&lt;GoalM action default value&gt;&quot;</span>)</span></span> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.modifyState"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1472-L1473">source</a></div><div class="attributes">@[implemented_by _private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.modifyStateImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.modifyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">modifyState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getStateCore"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1478-L1479">source</a></div><div class="attributes">@[implemented_by _private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.getStateCoreImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getStateCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getStateCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1481-L1482">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">σ</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getState">getState</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getStateCore">getStateCore</a></span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.getState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.internalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1484-L1486">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Internalizes given expression in all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.internalize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.checkInvariants"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1488-L1490">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.checkInvariants"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">checkInvariants</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Checks invariants of all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.checkInvariants" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.check"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1492-L1502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Performs (expensive) satisfiability checks in all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.check" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mbtc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1504-L1510">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mbtc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mbtc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Invokes model-based theory combination extensions in all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mbtc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.propagateDiseqs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1512-L1529">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.propagateDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">propagateDiseqs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a new disequality <code>lhs ≠ rhs</code>, propagates it to relevant theories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.propagateDiseqs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isSameSolverTerms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1557-L1558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isSameSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isSameSolverTerms</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isSameSolverTerms">Lean.Meta.Grind.isSameSolverTerms</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isSameSolverTerms.unsafe_impl_3">Lean.Meta.Grind.isSameSolverTerms.unsafe_impl_3✝</a> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isSameSolverTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.markTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1560-L1581">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.markTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">markTerm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.markTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1583-L1591">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getTerm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns <code>some t</code> if <code>t</code> is the solver term for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code> associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getTerm">getTerm</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.getTerm.go">Lean.Meta.Grind.SolverExtension.getTerm.go✝</a> <span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.id">id</a></span> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.sTerms">sTerms</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.getTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1593-L1602">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">hasTermAtRoot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the root of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class is already attached to a term
of the given solver.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.hasTermAtRoot">hasTermAtRoot</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.hasTermAtRoot.go">Lean.Meta.Grind.SolverExtension.hasTermAtRoot.go✝</a> <span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.id">id</a></span> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.sTerms">sTerms</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.hasTermAtRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PendingSolverPropagations"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1609-L1610">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.mk"><li id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.data" class="structure_field"><div class="structure_field_info">data : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagationsData">Lean.Meta.Grind.PendingSolverPropagationsData✝</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.PendingSolverPropagations" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mergeTerms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1612-L1639">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mergeTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mergeTerms</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rhsRoot </span><span class="fn">lhsRoot</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations">PendingSolverPropagations</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mergeTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PendingSolverPropagations.propagate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Meta/Tactic/Grind/Types.lean#L1641-L1652">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations.propagate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span>.<span class="name">propagate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations">PendingSolverPropagations</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations.propagate">propagate</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.propagate.go">Lean.Meta.Grind.PendingSolverPropagations.propagate.go✝</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.data">Lean.Meta.Grind.PendingSolverPropagations.data✝</a> <span class="fn">p</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.PendingSolverPropagations.propagate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>