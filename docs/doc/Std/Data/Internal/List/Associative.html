<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Data.Internal.List.Associative</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Std.Data.Internal.List.Associative";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Data</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Associative</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init/Data/BEq.html">Init.Data.BEq</a></li><li><a href="../../../.././Init/Data/List/Find.html">Init.Data.List.Find</a></li><li><a href="../../../.././Init/Data/List/MinMax.html">Init.Data.List.MinMax</a></li><li><a href="../../../.././Init/Data/List/Monadic.html">Init.Data.List.Monadic</a></li><li><a href="../../../.././Init/Data/List/Perm.html">Init.Data.List.Perm</a></li><li><a href="../../../.././Init/Data/Nat/Simproc.html">Init.Data.Nat.Simproc</a></li><li><a href="../../../.././Init/Data/Option/Attach.html">Init.Data.Option.Attach</a></li><li><a href="../../../.././Init/Data/Order/Lemmas.html">Init.Data.Order.Lemmas</a></li><li><a href="../../../.././Init/Data/Order/Ord.html">Init.Data.Order.Ord</a></li><li><a href="../../../.././Init/Data/Subtype/Order.html">Init.Data.Subtype.Order</a></li><li><a href="../../../.././Std/Data/Internal/List/Defs.html">Std.Data.Internal.List.Defs</a></li><li><a href="../../../.././Std/Data/Internal/List/Defs.html">Std.Data.Internal.List.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Data.Internal.List.Associative" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_iff'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div></nav><main>
<div class="mod_doc"><p>This is an internal implementation file of the hash map. Users of the hash map should not rely on
the contents of this file.</p><p>File contents: Verification of associative lists</p></div><div class="decl" id="Std.Internal.List.assoc_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L44-L50">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">nil</span> : <span class="fn"><span class="fn">motive</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cons</span> : <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) (<span class="fn">tail</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">tail</span></span> → <span class="fn"><span class="fn">motive</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L52-L55">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L57-L58">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L59-L60">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_find"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L62-L66">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L68-L70">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L72-L74">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L76-L79">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.beq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L81-L91">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L93-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L103-L107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L109-L131">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">e</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L133-L135">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L137-L140">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L142-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L151-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L156-L156">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L157-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L160-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L164-L166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L168-L171">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L173-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L182-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L186-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L192-L196">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L198-L199">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L200-L202">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L204-L207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L209-L211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L213-L216">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L218-L220">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L271-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L275-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L279-L282">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</li></ul></details><details id="instances-for-list-Std.Internal.List.containsKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L284-L285">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L286-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L289-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L293-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L300-L302">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L304-L305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L307-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L313-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_true_iff_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L322-L324">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L326-L328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_contains_map_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L330-L337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L339-L339">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L340-L341">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_keys_eq_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L343-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_keys_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L346-L347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_keys_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L349-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L355-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L359-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L363-L366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L370-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L374-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L378-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L382-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L386-L388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.of_keys_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L390-L392">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_iff_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L394-L396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L398-L401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L403-L405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_cons_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L407-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L416-L418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L420-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L424-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L428-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L432-L434">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L436-L438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L440-L443">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L445-L448">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L450-L452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L454-L456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L458-L461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValue_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L463-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L468-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L472-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L476-L478">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hla</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L480-L482">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">Std.Internal.List.getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L484-L486">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L488-L490">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L492-L494">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L496-L499">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L501-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L506-L519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L521-L536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L542-L544">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">Std.Internal.List.getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L546-L548">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L550-L554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L556-L558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L560-L563">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L565-L568">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L570-L577">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L579-L582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L584-L595">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getEntry_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L597-L599">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L603-L606">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">Std.Internal.List.getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L608-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L612-L616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L618-L626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L628-L644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L646-L661">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L663-L667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L669-L671">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">Std.Internal.List.getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCastD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCastD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L673-L675">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L680-L684">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L686-L689">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L691-L694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L696-L699">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">Std.Internal.List.getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L701-L703">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L705-L706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L708-L712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L714-L716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L718-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCastD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L723-L724">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L730-L732">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">Std.Internal.List.getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L734-L736">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L738-L739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L741-L744">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L746-L748">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L750-L752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L754-L756">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L758-L760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L762-L764">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">Std.Internal.List.getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L766-L768">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L770-L771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L773-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L778-L780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L782-L784">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L786-L788">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L790-L792">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L794-L795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L799-L802">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L804-L805">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L807-L808">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L810-L812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L814-L816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L818-L825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.fst_mem_keys_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L827-L829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L831-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L843-L849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L851-L856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L858-L860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L862-L872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L874-L880">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L882-L884">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">Std.Internal.List.getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L886-L888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L890-L897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L899-L906">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_iff'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k'</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L908-L910">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L912-L915">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L917-L919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L921-L923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h''</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">h''</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L925-L955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getEntry_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L957-L959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L961-L996">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">k</span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L998-L1000">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">Std.Internal.List.getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKeyD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1002-L1004">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1006-L1007">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1009-L1013">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1015-L1018">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1020-L1022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1024-L1027">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1029-L1032">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1034-L1036">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">Std.Internal.List.getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1038-L1040">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1042-L1043">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1045-L1049">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1051-L1053">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1055-L1057">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1059-L1062">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1064-L1067">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1069-L1070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1072-L1083">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1085-L1096">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1098-L1101">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.replaceEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.replaceEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1103-L1103">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1104-L1106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1108-L1110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1112-L1115">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1117-L1123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1125-L1131">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1133-L1146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1148-L1151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1153-L1156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1158-L1168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1170-L1181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1183-L1191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1193-L1200">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1202-L1207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1209-L1218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1220-L1226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1228-L1231">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1237-L1239">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1241-L1244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1246-L1249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1253-L1267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1269-L1279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1281-L1284">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.eraseKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.eraseKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1286-L1286">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1288-L1289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1291-L1293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1295-L1298">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1300-L1302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1304-L1310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1312-L1327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1329-L1331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.sublist_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1333-L1341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1343-L1358">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1360-L1362">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1364-L1367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1369-L1374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1376-L1388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1390-L1400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkv</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1402-L1404">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1406-L1409">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1411-L1417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1419-L1421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1423-L1426">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1428-L1430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1432-L1434">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1436-L1444">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1446-L1449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1451-L1457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1459-L1464">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1466-L1468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1470-L1473">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1475-L1478">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1484-L1488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1490-L1492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1494-L1498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1500-L1504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1506-L1508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1512-L1517">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1519-L1525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1527-L1529">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1531-L1534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1536-L1538">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1540-L1545">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1547-L1549">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1551-L1554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1556-L1558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1560-L1563">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1565-L1567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1569-L1574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1576-L1578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1580-L1582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1584-L1587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1589-L1591">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1593-L1596">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1598-L1600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1602-L1606">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1608-L1610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1612-L1614">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1616-L1619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1621-L1627">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1629-L1631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1633-L1639">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1641-L1643">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1645-L1650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1652-L1654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1656-L1658">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntryIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1660-L1662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1664-L1666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1668-L1676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1678-L1684">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1686-L1691">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1693-L1700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1702-L1706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1708-L1719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1721-L1723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1725-L1728">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1730-L1740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href="../../../.././Init/Prelude.html#Not">¬</a>((<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>))</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div><p>This is a restatement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew">containsKey_insertEntryIfNew</a></code> that is written to exactly match the proof
obligation in the statement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew">getValueCast_insertEntryIfNew</a></code>.</p></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1742-L1750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1752-L1758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1760-L1764">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1766-L1769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1771-L1776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1778-L1782">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1784-L1790">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1792-L1798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1800-L1803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1805-L1808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1810-L1812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1814-L1817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1819-L1822">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1824-L1832">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1834-L1836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1838-L1848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1850-L1852">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1854-L1866">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1868-L1873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1875-L1882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_keys_iff_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1884-L1890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1892-L1912">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1914-L1934">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1936-L1939">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1941-L1947">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1949-L1951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1953-L1955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1961-L1963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1965-L1967">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1969-L1971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1973-L1976">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1980-L1986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1988-L1990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1992-L1995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L1997-L1999">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2001-L2004">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2006-L2008">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2010-L2012">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2014-L2016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2018-L2020">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2022-L2024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2026-L2039">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2041-L2045">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2047-L2053">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2055-L2057">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2059-L2062">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2064-L2066">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2068-L2072">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2074-L2077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2079-L2082">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2084-L2087">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2089-L2092">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2094-L2097">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2099-L2101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2103-L2108">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2110-L2115">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2117-L2122">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2124-L2138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2140-L2148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2150-L2152">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2154-L2158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2160-L2163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2165-L2168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2174-L2176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2178-L2182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2184-L2186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2188-L2191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2195-L2197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2199-L2203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2205-L2208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2210-L2213">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_cons_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2215-L2225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">l'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l'</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2228-L2246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2248-L2252">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2254-L2270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) (<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">h'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2272-L2278">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2280-L2292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2294-L2301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2303-L2306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2308-L2311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2313-L2317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2319-L2322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2324-L2329">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2331-L2333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2335-L2338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_flatMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2340-L2351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) (<span class="fn">h</span> : <span class="fn">i</span> <a href="../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">l</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">]</a>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.flatMap">List.flatMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2353-L2355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2357-L2360">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2362-L2364">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2366-L2370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2372-L2375">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2377-L2382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2384-L2387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2389-L2394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2396-L2404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2406-L2413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2415-L2421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2423-L2428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2430-L2438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2440-L2449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2451-L2455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2457-L2460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2462-L2465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.map_fst_map_toProd_eq_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2467-L2473">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2475-L2479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2481-L2489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2491-L2501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2503-L2507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2509-L2522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2524-L2527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2529-L2543">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2546-L2550">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false_map_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2552-L2557">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2559-L2565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2567-L2573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2575-L2581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2583-L2589">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2591-L2597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2599-L2605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2607-L2612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">l</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2614-L2620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2622-L2630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2632-L2637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2639-L2645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2647-L2653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2655-L2660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2662-L2667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2669-L2678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2680-L2689">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2691-L2695">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l_1</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">l_1</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2697-L2704">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">List.insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2706-L2713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2 </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2715-L2733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2735-L2750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2752-L2762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2764-L2772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2774-L2786">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2788-L2791">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2793-L2799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2801-L2816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2818-L2826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2828-L2838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2840-L2845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2847-L2856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2858-L2863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_mem</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2865-L2874">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2876-L2882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2884-L2894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2896-L2903">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2905-L2914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2916-L2920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_false</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2922-L2930">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2932-L2936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2938-L2946">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2948-L2965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">toInsert</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2967-L2973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2975-L2980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2982-L2991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L2993-L3000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Prod.toSigma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3006-L3007">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">p</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>, <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Std.Internal.List.Prod.toSigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Prod.fst_comp_toSigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3009-L3013">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">toSigma</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertListConst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3015-L3017">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">Std.Internal.List.insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">toInsert</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListConst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3019-L3025">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3027-L3033">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3035-L3041">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3043-L3054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3056-L3063">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3065-L3074">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3076-L3081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3083-L3091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3093-L3098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3100-L3108">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3110-L3120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3122-L3127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3129-L3134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3136-L3141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3143-L3150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3152-L3177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3179-L3186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3188-L3197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3199-L3204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3206-L3214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3216-L3221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3223-L3231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v </span><span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3233-L3238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> (<span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tl</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a> <span class="fn">l</span>)</span> <span class="fn">tl</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListIfNewUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3240-L3256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3258-L3265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">List.insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3267-L3287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">toInsert</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.mapUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3289-L3294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3296-L3309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3311-L3319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3321-L3326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3328-L3334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3336-L3352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3354-L3360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3362-L3370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3372-L3378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">contains</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3380-L3387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3389-L3396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3398-L3403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3405-L3411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3413-L3420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3422-L3428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3430-L3473">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3475-L3480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3482-L3492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3494-L3501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_list_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3503-L3511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3513-L3517">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3536-L3541">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">Std.Internal.List.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3543-L3551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3553-L3562">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3564-L3583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(if hk : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v'</span>)</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3585-L3590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3592-L3595">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3597-L3602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3604-L3609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3611-L3615">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3617-L3628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3630-L3644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3646-L3651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">List.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_alterKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3653-L3657">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3659-L3682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3684-L3704">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3706-L3712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3714-L3725">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3727-L3734">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3736-L3744">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3746-L3758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3760-L3778">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3780-L3791">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3801-L3806">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Std.Internal.List.Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3808-L3816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3818-L3827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3829-L3832">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_sub_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3834-L3837">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3839-L3842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3844-L3847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3849-L3869">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  (<a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a>
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v'</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3871-L3875">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3877-L3880">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3882-L3888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3890-L3895">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3897-L3901">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3903-L3916">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3918-L3923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3925-L3942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3944-L3965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3967-L3985">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3987-L3992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L3994-L4002">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4004-L4012">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4014-L4022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4024-L4031">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4033-L4050">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4052-L4063">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.constAlterKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4067-L4070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constAlterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4072-L4078">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4084-L4089">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">Std.Internal.List.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4091-L4097">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4099-L4105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4107-L4114">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4116-L4120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4122-L4124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">List.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4126-L4129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4131-L4138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4140-L4144">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4146-L4161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4163-L4168">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4170-L4177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4179-L4183">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4185-L4192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4194-L4198">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4200-L4207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4209-L4212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4214-L4221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4223-L4226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4228-L4236">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4238-L4242">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4244-L4251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4253-L4256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4262-L4267">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Std.Internal.List.Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4269-L4275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4277-L4281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4283-L4286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4288-L4294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4296-L4303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4305-L4312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4314-L4317">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4319-L4333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4335-L4340">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4342-L4348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4350-L4354">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4356-L4363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4365-L4369">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4371-L4378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4380-L4383">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4385-L4391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4393-L4396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4398-L4407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4409-L4413">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4415-L4422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4424-L4427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.constModifyKey_eq_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4431-L4435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constModifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4437-L4439">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.guard_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4485-L4488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.guard">Option.guard</a> <span class="fn">fun (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">p</span> <span class="fn">b</span>)</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt;
  <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">y</span> : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">y</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> (<a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Sigma.snd_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4490-L4492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">x'</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4508-L4532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4534-L4539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), (<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4541-L4547">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4549-L4556">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4558-L4565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4567-L4575">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4577-L4584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4586-L4594">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">y</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4596-L4602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4604-L4613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4615-L4624">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4626-L4634">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4636-L4650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4652-L4666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4668-L4673">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.apply_eq_true_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4675-L4685">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4687-L4696">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4698-L4703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4705-L4710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4712-L4723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4725-L4730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4732-L4737">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4739-L4748">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4750-L4755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4757-L4762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4764-L4770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4772-L4777">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4779-L4784">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4786-L4791">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">x</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4793-L4798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4800-L4805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Option.exists_eq_some_and_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4807-L4809">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">o</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4811-L4817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4819-L4825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4827-L4836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4838-L4845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4847-L4860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4862-L4868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4870-L4876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_get_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4878-L4881">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4883-L4894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4896-L4913">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4915-L4921">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4923-L4926">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4928-L4934">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4936-L4939">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4941-L4944">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4946-L4949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4951-L4954">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4956-L4959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4961-L4965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4967-L4971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4973-L4980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4982-L4990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4992-L4997">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L4999-L5014">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.key_getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5016-L5027">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5029-L5039">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5041-L5046">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5048-L5062">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5064-L5068">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5070-L5079">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5081-L5092">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5094-L5106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5108-L5113">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5115-L5120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5122-L5127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5129-L5134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_key_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5136-L5149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_getValue_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5153-L5162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5164-L5175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5177-L5187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5189-L5198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5200-L5205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5207-L5214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5216-L5221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5223-L5230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
      <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5232-L5243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5245-L5254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5256-L5261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5263-L5269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5271-L5276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5278-L5283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5285-L5293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5295-L5299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5301-L5306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5308-L5312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5314-L5319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5321-L5325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5327-L5340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5342-L5348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5350-L5356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_eq_get_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5358-L5361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5363-L5373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5375-L5381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5383-L5389">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5391-L5406">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5408-L5413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5415-L5420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5422-L5427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5429-L5434">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5436-L5441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5443-L5448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5450-L5454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5456-L5460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5462-L5465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5467-L5470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5510-L5512">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Like <code><a href="../../../.././Init/Data/List/Basic.html#List.min?">List.min?</a></code>, but using an <code><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a></code> typeclass instead of a <code><a href="../../../.././Init/Prelude.html#Min">Min</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.min?">min?</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5514-L5516">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5518-L5530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hma</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmb</span> : <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_head?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5542-L5544">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5546-L5548">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5557-L5561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5581-L5597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5599-L5608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5610-L5622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5624-L5632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5634-L5637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5639-L5641">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5643-L5645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5647-L5649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minEntry?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5651-L5654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5656-L5658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5660-L5664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5666-L5668">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5670-L5672">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5679-L5690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">e₂</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₁</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₂</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5692-L5711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5713-L5723">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5725-L5731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5733-L5753">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">w</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5755-L5760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5762-L5765">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5767-L5770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5772-L5775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5777-L5780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5782-L5786">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">em</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hem</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">em</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5788-L5794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5796-L5799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5810-L5815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5817-L5821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5823-L5827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5829-L5834">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5836-L5841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5843-L5850">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5852-L5858">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5860-L5865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5867-L5875">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5877-L5882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5884-L5894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5896-L5899">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5901-L5906">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5908-L5915">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kme</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5917-L5924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> (<span class="fn">e</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">w</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5926-L5955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5957-L5962">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5964-L5967">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5969-L5972">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5974-L5979">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5981-L5992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_head?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5994-L5997">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L5999-L6004">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6006-L6022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6028-L6046">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6048-L6055">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6057-L6060">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6062-L6065">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6067-L6077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6079-L6096">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6100-L6102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6104-L6107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_get_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6109-L6112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6114-L6117">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6119-L6123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6125-L6128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6130-L6134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6136-L6140">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6142-L6146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6148-L6151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6153-L6156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6158-L6162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6164-L6167">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6169-L6172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6174-L6177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6179-L6182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6184-L6196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6198-L6203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_minKey_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6205-L6209">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6211-L6215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6217-L6221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6223-L6226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_head_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6228-L6232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head">head</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6234-L6237">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6239-L6243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6249-L6256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6258-L6261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6263-L6266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6268-L6272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6276-L6278">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or panics if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">Std.Internal.List.minKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6280-L6283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_get!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6285-L6288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6290-L6293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6295-L6298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6300-L6303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6305-L6308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6310-L6314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6316-L6320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6322-L6325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6327-L6330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6332-L6335">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6337-L6340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6342-L6345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6347-L6350">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6352-L6355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6357-L6360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6362-L6365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6367-L6370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6372-L6376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6378-L6382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6384-L6388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_minKey!_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6390-L6393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6395-L6399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6401-L6404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6406-L6409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_head!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6411-L6417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.head!">head!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6419-L6426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6428-L6433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6439-L6442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6444-L6451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6453-L6460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6462-L6466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6470-L6472">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6474-L6477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_getD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6479-L6482">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6484-L6487">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6489-L6492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_minKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6494-L6497">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6499-L6502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6504-L6509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6511-L6516">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6518-L6522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6524-L6527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6529-L6532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6534-L6537">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6539-L6542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6544-L6547">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6549-L6552">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6554-L6558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6560-L6564">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6566-L6569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6571-L6574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6576-L6582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6584-L6590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6592-L6597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_minKeyD_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6599-L6604">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6606-L6610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6612-L6616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6618-L6621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_headD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6623-L6626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.headD">headD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6628-L6635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6637-L6642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6648-L6652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6654-L6661">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6663-L6670">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6672-L6677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6685-L6688">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6690-L6694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6696-L6700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6702-L6706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6708-L6711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6713-L6716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_maxKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6718-L6721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6723-L6726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6728-L6731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6733-L6738">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6740-L6744">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6746-L6750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6752-L6756">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6758-L6762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6764-L6768">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6770-L6774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6776-L6780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6782-L6786">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6788-L6792">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6794-L6799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6801-L6806">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6808-L6813">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6815-L6820">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6822-L6827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6829-L6833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6835-L6840">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6842-L6849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">kme</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6851-L6856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6858-L6862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6864-L6869">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6871-L6876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.reverse_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6878-L6880">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_getLast?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6882-L6888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast?">getLast?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6890-L6894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6896-L6901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6907-L6911">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6913-L6917">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6919-L6923">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6925-L6929">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6931-L6937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6939-L6944">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6948-L6950">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">Std.Internal.List.maxKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6952-L6956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_get_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6958-L6961">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6963-L6967">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6969-L6973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6975-L6979">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6981-L6986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6988-L6992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L6994-L6998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7000-L7004">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7006-L7010">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7012-L7016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7018-L7022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7024-L7028">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7030-L7034">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7036-L7040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7042-L7048">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7050-L7056">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_le_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7058-L7063">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7065-L7070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7072-L7077">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7079-L7083">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_getLast_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7085-L7091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast">getLast</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7093-L7097">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7099-L7104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7110-L7118">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7120-L7124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7126-L7130">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7132-L7137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7141-L7143">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">Std.Internal.List.maxKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7145-L7149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_get!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7151-L7155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7157-L7161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7163-L7167">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7169-L7173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7175-L7179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7181-L7186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7188-L7193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7195-L7199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7201-L7205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7207-L7211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey!_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7213-L7217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7219-L7223">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7225-L7229">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7231-L7235">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7237-L7241">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7243-L7247">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7249-L7253">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7255-L7260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7262-L7267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7269-L7274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_erase_le_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7276-L7280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7282-L7287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7289-L7293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7295-L7299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_getLast!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7301-L7306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.getLast!">getLast!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7308-L7312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7314-L7320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7326-L7330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7332-L7336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7338-L7342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7344-L7349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7353-L7355">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">Std.Internal.List.maxKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7357-L7361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7363-L7367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7369-L7373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7375-L7379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_maxKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7381-L7385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7387-L7391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7393-L7398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7400-L7405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7407-L7412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7414-L7418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7420-L7424">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7426-L7430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKeyD_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7432-L7436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7438-L7442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7444-L7448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7450-L7454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7456-L7460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7462-L7466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7468-L7472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7474-L7480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7482-L7488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7490-L7495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7497-L7502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7504-L7509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7511-L7515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7517-L7521">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getLastD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7523-L7528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLastD">getLastD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7530-L7534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7536-L7542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7548-L7553">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7555-L7559">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7561-L7565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Std/Data/Internal/List/Associative.lean#L7567-L7573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord/Basic.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Order/Ord.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord/Basic.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>