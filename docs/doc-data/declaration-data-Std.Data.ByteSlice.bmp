{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_8\"><span class=\"name\">instSliceableByteSliceNat_8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rii.Sliceable\">Std.Rii.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_8","kind":"instance","line":419,"name":"instSliceableByteSliceNat_8","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L419-L422"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_7\"><span class=\"name\">instSliceableByteSliceNat_7</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rio.Sliceable\">Std.Rio.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_7","kind":"instance","line":414,"name":"instSliceableByteSliceNat_7","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L414-L417"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_6\"><span class=\"name\">instSliceableByteSliceNat_6</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Ric.Sliceable\">Std.Ric.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_6","kind":"instance","line":409,"name":"instSliceableByteSliceNat_6","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L409-L412"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_5\"><span class=\"name\">instSliceableByteSliceNat_5</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roi.Sliceable\">Std.Roi.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_5","kind":"instance","line":404,"name":"instSliceableByteSliceNat_5","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L404-L407"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_4\"><span class=\"name\">instSliceableByteSliceNat_4</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roo.Sliceable\">Std.Roo.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_4","kind":"instance","line":399,"name":"instSliceableByteSliceNat_4","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L399-L402"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_3\"><span class=\"name\">instSliceableByteSliceNat_3</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roc.Sliceable\">Std.Roc.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_3","kind":"instance","line":394,"name":"instSliceableByteSliceNat_3","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L394-L397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_2\"><span class=\"name\">instSliceableByteSliceNat_2</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rci.Sliceable\">Std.Rci.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_2","kind":"instance","line":389,"name":"instSliceableByteSliceNat_2","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L389-L392"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_1\"><span class=\"name\">instSliceableByteSliceNat_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rco.Sliceable\">Std.Rco.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat_1","kind":"instance","line":384,"name":"instSliceableByteSliceNat_1","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L384-L387"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteSliceNat\"><span class=\"name\">instSliceableByteSliceNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rcc.Sliceable\">Std.Rcc.Sliceable</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteSliceNat","kind":"instance","line":379,"name":"instSliceableByteSliceNat","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L379-L382"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_8\"><span class=\"name\">instSliceableByteArrayNatByteSlice_8</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rii.Sliceable\">Std.Rii.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_8","kind":"instance","line":370,"name":"instSliceableByteArrayNatByteSlice_8","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L370-L373"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_7\"><span class=\"name\">instSliceableByteArrayNatByteSlice_7</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rio.Sliceable\">Std.Rio.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_7","kind":"instance","line":365,"name":"instSliceableByteArrayNatByteSlice_7","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L365-L368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_6\"><span class=\"name\">instSliceableByteArrayNatByteSlice_6</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Ric.Sliceable\">Std.Ric.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_6","kind":"instance","line":360,"name":"instSliceableByteArrayNatByteSlice_6","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L360-L363"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_5\"><span class=\"name\">instSliceableByteArrayNatByteSlice_5</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roi.Sliceable\">Std.Roi.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_5","kind":"instance","line":355,"name":"instSliceableByteArrayNatByteSlice_5","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L355-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_4\"><span class=\"name\">instSliceableByteArrayNatByteSlice_4</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roo.Sliceable\">Std.Roo.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_4","kind":"instance","line":350,"name":"instSliceableByteArrayNatByteSlice_4","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L350-L353"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_3\"><span class=\"name\">instSliceableByteArrayNatByteSlice_3</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Roc.Sliceable\">Std.Roc.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_3","kind":"instance","line":345,"name":"instSliceableByteArrayNatByteSlice_3","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L345-L348"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_2\"><span class=\"name\">instSliceableByteArrayNatByteSlice_2</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rci.Sliceable\">Std.Rci.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_2","kind":"instance","line":340,"name":"instSliceableByteArrayNatByteSlice_2","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L340-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_1\"><span class=\"name\">instSliceableByteArrayNatByteSlice_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rco.Sliceable\">Std.Rco.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice_1","kind":"instance","line":335,"name":"instSliceableByteArrayNatByteSlice_1","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L335-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice\"><span class=\"name\">instSliceableByteArrayNatByteSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Notation.html#Std.Rcc.Sliceable\">Std.Rcc.Sliceable</a> <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSliceableByteArrayNatByteSlice","kind":"instance","line":330,"name":"instSliceableByteArrayNatByteSlice","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L330-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteArray.toByteSlice\"><span class=\"name\">ByteArray</span>.<span class=\"name\">toByteSlice</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">as</span> : <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">start</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stop</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\"><span class=\"fn\">as</span>.<a href=\"./Init/Prelude.html#ByteArray.size\">size</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></div></div>","info":{"doc":"Returns a byte slice of a byte array, with the given bounds.\n\nIf `start` or `stop` are not valid bounds for a byte slice, then they are clamped to byte array's size.\nAdditionally, the starting index is clamped to the ending index.\n","docLink":"./Std/Data/ByteSlice.html#ByteArray.toByteSlice","kind":"def","line":294,"name":"ByteArray.toByteSlice","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L294-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.contains\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">contains</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">byte</span> : <a href=\"./Init/Prelude.html#UInt8\">UInt8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Checks if the byte slice contains a specific byte value.\n\nReturns `true` if any byte in the slice equals the given value, `false` otherwise.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.contains","kind":"def","line":276,"name":"ByteSlice.contains","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L276-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.slice\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">slice</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">start</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stop</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a> := <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.size\">size</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></div></div>","info":{"doc":"Creates a sub-slice of the byte slice with the given bounds.\n\nIf `start` or `stop` are not valid bounds for a sub-slice, then they are clamped to the slice's size.\nAdditionally, the starting index is clamped to the ending index.\n\nThe indices are relative to the current slice, not the underlying byte array.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.slice","kind":"def","line":245,"name":"ByteSlice.slice","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L245-L274"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.foldr\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">foldr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">init</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">as</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">β</span></div></div>","info":{"doc":"Folds an operation from right to left over the bytes in a byte slice.\n\nAn accumulator of type `β` is constructed by starting with `init` and combining each byte of the\nbyte slice with the current accumulator value in turn, moving from the end to the start.\n\nExamples:\n * `(ByteArray.mk #[1, 2, 3]).toByteSlice.foldr (·.toNat + ·) 0 = 6`\n * `(ByteArray.mk #[1, 2, 3]).toByteSlice.popFront.foldr (·.toNat + ·) 0 = 5`\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.foldr","kind":"def","line":231,"name":"ByteSlice.foldr","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L231-L243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.forM\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">forM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">as</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#PUnit\">PUnit</a></span></div></div>","info":{"doc":"Runs a monadic action on each byte of a byte slice.\n\nThe bytes are processed starting at the lowest index and moving up.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.forM","kind":"def","line":216,"name":"ByteSlice.forM","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L216-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.foldrM\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">foldrM</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> v}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> v → <a href=\"./foundational_types.html\">Type</a> w</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">init</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">as</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"Folds a monadic operation from right to left over the bytes in a byte slice.\n\nAn accumulator of type `β` is constructed by starting with `init` and monadically combining each\nbyte of the byte slice with the current accumulator value in turn, moving from the end to the\nstart. The monad in question may permit early termination or repetition.\n\nExamples:\n```lean example\n#eval (ByteArray.mk #[1, 2, 3]).toByteSlice.foldrM (init := 0) fun x acc =>\n  some x.toNat + acc\n```\n```output\nsome 6\n```\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.foldrM","kind":"def","line":190,"name":"ByteSlice.foldrM","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L190-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.instBEq\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">instBEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#ByteSlice.instBEq","kind":"instance","line":188,"name":"ByteSlice.instBEq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L188-L188"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.beq\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Comparison function\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.beq","kind":"def","line":181,"name":"ByteSlice.beq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L181-L186"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.toByteArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">toByteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a></div></div>","info":{"doc":"Converts a byte slice back to a byte array by copying the relevant portion.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.toByteArray","kind":"def","line":175,"name":"ByteSlice.toByteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L175-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.instInhabited\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">instInhabited</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#ByteSlice.instInhabited","kind":"instance","line":172,"name":"ByteSlice.instInhabited","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L172-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.instEmptyCollection\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">instEmptyCollection</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection\">EmptyCollection</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#ByteSlice.instEmptyCollection","kind":"instance","line":169,"name":"ByteSlice.instEmptyCollection","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L169-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.ofByteArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">ofByteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ba</span> : <a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></div></div>","info":{"doc":"Creates a new ByteSlice of a ByteArray\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.ofByteArray","kind":"def","line":158,"name":"ByteSlice.ofByteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L158-L167"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.empty\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">empty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></div></div>","info":{"doc":"The empty byte slice.\n\nThis empty byte slice is backed by an empty byte array.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.empty","kind":"def","line":145,"name":"ByteSlice.empty","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L145-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.get!\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">get!</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>","info":{"doc":"Extracts a byte from the byte slice, or returns a default value when the index is out of bounds.\n\nThe index is relative to the start and end of the byte slice, rather than the underlying byte array. The\ndefault value is 0.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.get!","kind":"def","line":136,"name":"ByteSlice.get!","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L136-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.getD\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">getD</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v₀</span> : <a href=\"./Init/Prelude.html#UInt8\">UInt8</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>","info":{"doc":"Extracts a byte from the byte slice, or returns a default value `v₀` when the index is out of\nbounds.\n\nThe index is relative to the start and end of the byte slice, rather than the underlying byte array.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.getD","kind":"def","line":127,"name":"ByteSlice.getD","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L127-L134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.instGetElemNatUInt8LtSize\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">instGetElemNatUInt8LtSize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/GetElem.html#GetElem\">GetElem</a> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#UInt8\">UInt8</a> <span class=\"fn\">fun (<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>) (<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>) =&gt; <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">xs</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.size\">size</a></span></span></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#ByteSlice.instGetElemNatUInt8LtSize","kind":"instance","line":124,"name":"ByteSlice.instGetElemNatUInt8LtSize","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L124-L125"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.get\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">get</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.size\">size</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>","info":{"doc":"Extracts a byte from the byte slice.\n\nThe index is relative to the start of the byte slice, rather than the underlying byte array.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.get","kind":"def","line":110,"name":"ByteSlice.get","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L110-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.size_le_size_byteArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">size_le_size_byteArray</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.size\">size</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.byteArray\">byteArray</a></span>.<a href=\"./Init/Prelude.html#ByteArray.size\">size</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#ByteSlice.size_le_size_byteArray","kind":"theorem","line":104,"name":"ByteSlice.size_le_size_byteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L104-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.size\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"Computes the size of the byte slice.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.size","kind":"def","line":98,"name":"ByteSlice.size","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L98-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.stop_le_size_byteArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">stop_le_size_byteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">xs</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.stop\">stop</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">xs</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.byteArray\">byteArray</a></span>.<a href=\"./Init/Prelude.html#ByteArray.size\">size</a></span></div></div>","info":{"doc":"The stopping index is no later than the end of the byte array.\n\nThe ending index is exclusive. If it is equal to the size of the byte array, then the last byte of\nthe byte array is in the byte slice.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.stop_le_size_byteArray","kind":"theorem","line":94,"name":"ByteSlice.stop_le_size_byteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L94-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.start_le_stop\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">start_le_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">xs</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.start\">start</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\">xs</span>.<a href=\"./Std/Data/ByteSlice.html#ByteSlice.stop\">stop</a></span></div></div>","info":{"doc":"The starting index is no later than the ending index.\n\nThe ending index is exclusive. If the starting and ending indices are equal, then the byte slice is\nempty.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.start_le_stop","kind":"theorem","line":90,"name":"ByteSlice.start_le_stop","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L90-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.stop\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The ending index of the region of interest (exclusive).\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.stop","kind":"def","line":86,"name":"ByteSlice.stop","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L86-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.start\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The starting index of the region of interest (inclusive).\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.start","kind":"def","line":82,"name":"ByteSlice.start","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L82-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice.byteArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">byteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a></div></div>","info":{"doc":"The underlying byte array.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice.byteArray","kind":"def","line":78,"name":"ByteSlice.byteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L78-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#instSelfSliceByteSliceDataByteSlice\"><span class=\"name\">instSelfSliceByteSliceDataByteSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Slice/Basic.html#Std.Slice.Self\">Std.Slice.Self</a> <span class=\"fn\">(<a href=\"./Init/Data/Slice/Basic.html#Std.Slice\">Std.Slice</a> <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">Std.Slice.Internal.ByteSliceData</a>)</span> <a href=\"./Std/Data/ByteSlice.html#ByteSlice\">ByteSlice</a></span></div></div>","info":{"doc":"","docLink":"./Std/Data/ByteSlice.html#instSelfSliceByteSliceDataByteSlice","kind":"instance","line":74,"name":"instSelfSliceByteSliceDataByteSlice","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L74-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#ByteSlice\"><span class=\"name\">ByteSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A region of some underlying byte array.\n\nA byte slice contains a byte array together with the start and end indices of a region of interest.\nByte slices can be used to avoid copying or allocating space, while being more convenient than\ntracking the bounds by hand. The region of interest consists of every index that is both greater\nthan or equal to `start` and strictly less than `stop`.\n","docLink":"./Std/Data/ByteSlice.html#ByteSlice","kind":"def","line":64,"name":"ByteSlice","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L64-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop_le_size_byteArray\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span>.<span class=\"name\">stop_le_size_byteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">ByteSliceData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop\">stop</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.byteArray\">byteArray</a></span>.<a href=\"./Init/Prelude.html#ByteArray.size\">size</a></span></div></div>","info":{"doc":"The stopping index is no later than the end of the byte array.\n\nThe ending index is exclusive. If it is equal to the size of the byte array, then the last byte of\nthe byte array is in the byte slice.\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop_le_size_byteArray","kind":"theorem","line":60,"name":"Std.Slice.Internal.ByteSliceData.stop_le_size_byteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L60-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.start_le_stop\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span>.<span class=\"name\">start_le_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">ByteSliceData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.start\">start</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop\">stop</a></span></div></div>","info":{"doc":"The starting index is no later than the ending index.\n\nThe ending index is exclusive. If the starting and ending indices are equal, then the byte slice is\nempty.\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.start_le_stop","kind":"theorem","line":53,"name":"Std.Slice.Internal.ByteSliceData.start_le_stop","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L53-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span>.<span class=\"name\">stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">ByteSliceData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The ending index of the region of interest (exclusive).\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.stop","kind":"def","line":45,"name":"Std.Slice.Internal.ByteSliceData.stop","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L45-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.start\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span>.<span class=\"name\">start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">ByteSliceData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>","info":{"doc":"The starting index of the region of interest (inclusive).\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.start","kind":"def","line":40,"name":"Std.Slice.Internal.ByteSliceData.start","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L40-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.byteArray\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span>.<span class=\"name\">byteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\">ByteSliceData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#ByteArray\">ByteArray</a></div></div>","info":{"doc":"The underlying byte array.\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData.byteArray","kind":"def","line":35,"name":"Std.Slice.Internal.ByteSliceData.byteArray","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L35-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData\"><span class=\"name\">Std</span>.<span class=\"name\">Slice</span>.<span class=\"name\">Internal</span>.<span class=\"name\">ByteSliceData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Internal representation of `ByteSlice`, which is an abbreviation for `Slice ByteSliceData`.\n","docLink":"./Std/Data/ByteSlice.html#Std.Slice.Internal.ByteSliceData","kind":"structure","line":26,"name":"Std.Slice.Internal.ByteSliceData","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Std/Data/ByteSlice.lean#L26-L60"}}],"imports":["Init.Data.ByteArray","Init.Data.Slice.Basic","Init.Data.Slice.Notation","Init.Data.Range.Polymorphic.Nat"],"instances":[{"className":"Std.Slice.Self","name":"instSelfSliceByteSliceDataByteSlice","typeNames":["Std.Slice","ByteSlice"]},{"className":"GetElem","name":"ByteSlice.instGetElemNatUInt8LtSize","typeNames":["ByteSlice","Nat","UInt8"]},{"className":"EmptyCollection","name":"ByteSlice.instEmptyCollection","typeNames":["ByteSlice"]},{"className":"Inhabited","name":"ByteSlice.instInhabited","typeNames":["ByteSlice"]},{"className":"BEq","name":"ByteSlice.instBEq","typeNames":["ByteSlice"]},{"className":"Std.Rcc.Sliceable","name":"instSliceableByteArrayNatByteSlice","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Rco.Sliceable","name":"instSliceableByteArrayNatByteSlice_1","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Rci.Sliceable","name":"instSliceableByteArrayNatByteSlice_2","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Roc.Sliceable","name":"instSliceableByteArrayNatByteSlice_3","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Roo.Sliceable","name":"instSliceableByteArrayNatByteSlice_4","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Roi.Sliceable","name":"instSliceableByteArrayNatByteSlice_5","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Ric.Sliceable","name":"instSliceableByteArrayNatByteSlice_6","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Rio.Sliceable","name":"instSliceableByteArrayNatByteSlice_7","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Rii.Sliceable","name":"instSliceableByteArrayNatByteSlice_8","typeNames":["ByteArray","Nat","ByteSlice"]},{"className":"Std.Rcc.Sliceable","name":"instSliceableByteSliceNat","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Rco.Sliceable","name":"instSliceableByteSliceNat_1","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Rci.Sliceable","name":"instSliceableByteSliceNat_2","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Roc.Sliceable","name":"instSliceableByteSliceNat_3","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Roo.Sliceable","name":"instSliceableByteSliceNat_4","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Roi.Sliceable","name":"instSliceableByteSliceNat_5","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Ric.Sliceable","name":"instSliceableByteSliceNat_6","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Rio.Sliceable","name":"instSliceableByteSliceNat_7","typeNames":["ByteSlice","Nat","ByteSlice"]},{"className":"Std.Rii.Sliceable","name":"instSliceableByteSliceNat_8","typeNames":["ByteSlice","Nat","ByteSlice"]}],"name":"Std.Data.ByteSlice"}