{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceHandler</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElabM\">Command.CommandElabM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"The main entry point to the `ToExpr` deriving handler.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler","kind":"def","line":224,"name":"Lean.Elab.Deriving.ToExpr.mkToExprInstanceHandler","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L224-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a>)</span></span></div></div>","info":{"doc":"Returns all the commands necessary to construct the `ToExpr` instances.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds","kind":"def","line":215,"name":"Lean.Elab.Deriving.ToExpr.mkToExprInstanceCmds","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L215-L222"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkInstanceCmds\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkInstanceCmds</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Command\">Command</a>)</span></span></div></div>","info":{"doc":"Assuming all of the auxiliary definitions exist,\ncreates all the `instance` commands for the `ToExpr` instances for the (mutual) inductive type(s).\nThis is a modified copy of `Lean.Elab.Deriving.mkInstanceCmds` to account for `ToLevel` instances.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkInstanceCmds","kind":"def","line":190,"name":"Lean.Elab.Deriving.ToExpr.mkInstanceCmds","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L190-L213"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunctions\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAuxFunctions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Syntax</a></span></div></div>","info":{"doc":"Creates all the auxiliary functions (using `mkAuxFunction`) for the (mutual) inductive type(s).\nWraps the resulting definition commands in `mutual ... end`.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunctions","kind":"def","line":179,"name":"Lean.Elab.Deriving.ToExpr.mkAuxFunctions","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L179-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunction\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAuxFunction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Command\">Command</a></span></div></div>","info":{"doc":"Makes a `toExpr` function for the given inductive type.\nThe implementation of each `toExpr` function for a (mutual) inductive type is given as top-level private definitions.\nThese are assembled into `ToExpr` instances in `mkInstanceCmds`.\nFor mutual/nested inductive types, then each of the types' `ToExpr` instances are provided as local instances,\nto wire together the recursion (necessitating these auxiliary definitions being `partial`).\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAuxFunction","kind":"def","line":144,"name":"Lean.Elab.Deriving.ToExpr.mkAuxFunction","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L144-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkLocalInstanceLetDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctx</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelInsts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.letDecl</span>))</span></span></div></div>","info":{"doc":"For nested and mutually recursive inductive types, we define `partial` instances,\nand the strategy is to have local `ToExpr` instances in scope for the body of each instance.\nThis way, each instance can freely use `toExpr` and `toTypeExpr` for each of the types in `ctx`.\n\nThis is a modified copy of `Lean.Elab.Deriving.mkLocalInstanceLetDecls`,\nsince we need to include the `toTypeExpr` field in the `letDecl`\nNote that, for simplicity, each instance gets its own definition of each others' `toTypeExpr` fields.\nThese are very simple fields, so avoiding the duplication is not worth it.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls","kind":"def","line":114,"name":"Lean.Elab.Deriving.ToExpr.mkLocalInstanceLetDecls","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L114-L141"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToExprBody</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">header</span> : <a href=\"./Lean/Elab/Deriving/Util.html#Lean.Elab.Deriving.Header\">Header</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">auxFunName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">levelInsts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span></div></div>","info":{"doc":"Creates the body of the `toExpr` function for the `ToExpr` instance, which is a `match` expression\nthat calls `toExpr` and `toTypeExpr` to assemble an expression for a given term.\nFor recursive inductive types, `auxFunName` refers to the `ToExpr` instance for the current type.\nFor mutually recursive types, we rely on the local instances set up by `mkLocalInstanceLetDecls`.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToExprBody","kind":"def","line":67,"name":"Lean.Elab.Deriving.ToExpr.mkToExprBody","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L67-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToTypeExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkToTypeExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">argNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span></div></div>","info":{"doc":"Creates a term that evaluates to an expression representing the inductive type.\nUses `toExpr` and `toTypeExpr` for the arguments to the type constructor.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkToTypeExpr","kind":"def","line":51,"name":"Lean.Elab.Deriving.ToExpr.mkToTypeExpr","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L51-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.updateIndType\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">updateIndType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">InductiveVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">TermElabM</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span></div></div>","info":{"doc":"Fixes the output of `mkInductiveApp` to explicitly reference universe levels. ","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.updateIndType","kind":"def","line":44,"name":"Lean.Elab.Deriving.ToExpr.updateIndType","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L44-L49"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAppNTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Deriving</span>.<span class=\"name\">ToExpr</span>.<span class=\"name\">mkAppNTerm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Term</a></span></div></div>","info":{"doc":"Given `args := #[e₁, e₂, …, eₙ]`, constructs the syntax `Expr.app (… (Expr.app (Expr.app f e₁) e₂) …) eₙ`.\n","docLink":"./Lean/Elab/Deriving/ToExpr.html#Lean.Elab.Deriving.ToExpr.mkAppNTerm","kind":"def","line":38,"name":"Lean.Elab.Deriving.ToExpr.mkAppNTerm","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Lean/Elab/Deriving/ToExpr.lean#L38-L42"}}],"imports":["Lean.Meta.Transform","Lean.Elab.Deriving.Basic","Lean.Elab.Deriving.Util","Lean.ToLevel","Lean.ToExpr"],"instances":[],"name":"Lean.Elab.Deriving.ToExpr"}