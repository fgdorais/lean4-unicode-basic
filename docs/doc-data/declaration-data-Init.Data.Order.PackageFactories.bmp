{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">ofOrd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">Packages.LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear order on a type `α` and all the associated\noperations and instances given an `Ord α` instance.\n\nCreates a `LinearOrderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α`,\n`Ord α`, `Min α` and `Max α` instances as well as an `IsLinearOrder α` instance and `LawfulOrder*`\ninstances proving the compatibility of the operations with the linear order.\n\nIn the presence of `Ord α`, `TransOrd α` and `LawfulEqOrd α` instances, no arguments are required\nand the factory can be used as in this\nexample:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X {\n  transOrd := sorry\n  eq_of_compare := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearOrderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearOrderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearOrderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq`, `Ord`, `Min` and `Max`, existing instances\n  are always preferred. If no existing instances can be synthesized, it is attempted to derive an\n  instance from the `Ord` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `Ord` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff`\n  can be omitted because Lean can infer that `BEq α` and `Ord α` are compatible.\n* Other proof obligations, such as `transOrd`, can be omitted if matching instances can be\n  synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofOrd","kind":"def","line":747,"name":"Std.LinearOrderPackage.ofOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L747-L806"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">max_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max\">max</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max_eq","kind":"theorem","line":737,"name":"Std.Packages.LinearOrderOfOrdArgs.max_eq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L737-L737"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">min_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min\">min</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min_eq","kind":"theorem","line":728,"name":"Std.Packages.LinearOrderOfOrdArgs.min_eq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L728-L728"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">max</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.max","kind":"def","line":721,"name":"Std.Packages.LinearOrderOfOrdArgs.max","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L721-L721"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">min</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.min","kind":"def","line":714,"name":"Std.Packages.LinearOrderOfOrdArgs.min","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L714-L714"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.eq_of_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">eq_of_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.eq_of_compare","kind":"theorem","line":705,"name":"Std.Packages.LinearOrderOfOrdArgs.eq_of_compare","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L705-L705"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toLinearPreorderOfOrdArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq_of_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun _ _ =&gt; _root_.Std.LawfulEqOrd.eq_of_compare\n  |\n    fail &quot;Failed to derive a `LawfulEqOrd` instance. \\\n                  Please make sure that it can be synthesized or \\\n                  manually provide the field `eq_of_compare`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instMinOfOrd)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instMaxOfOrd)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">min</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>       <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun a b =&gt; _root_.Std.min_eq_if_isLE_compare (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `min` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMin` instance can be synthesized or \\\n                  manually provide the field `min_eq`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfOrdArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">max</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>       <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun a b =&gt; _root_.Std.max_eq_if_isGE_compare (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `max` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMax` instance can be synthesized or \\\n                  manually provide the field `max_eq`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.mk","kind":"ctor","line":703,"name":"Std.Packages.LinearOrderOfOrdArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L703-L703"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span>.<span class=\"name\">toLinearPreorderOfOrdArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\">LinearOrderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs","kind":"def","line":703,"name":"Std.Packages.LinearOrderOfOrdArgs.toLinearPreorderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L703-L745"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfOrdArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">Std.Packages.LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearOrderPackage α` instance.\nIts fields are automatically provided if possible. For the detailed rules how the fields are\ninferred, see `LinearOrderPackage.ofOrd`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfOrdArgs","kind":"structure","line":698,"name":"Std.Packages.LinearOrderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L698-L745"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderLeftLeaningMaxOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMax\">LawfulOrderLeftLeaningMax</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","kind":"instance","line":690,"name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L690-L694"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderLeftLeaningMinOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLeftLeaningMin\">LawfulOrderLeftLeaningMin</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","kind":"instance","line":684,"name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L684-L688"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instMaxOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMaxOfOrd","kind":"def","line":680,"name":"Std.FactoryInstances.instMaxOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L680-L682"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instMinOfOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instMinOfOrd","kind":"def","line":676,"name":"Std.FactoryInstances.instMinOfOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L676-L678"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">ofOrd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">Packages.LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear preorder on a type `α` and all the associated\noperations and instances given an `Ord α` instance.\n\nCreates a `LinearPreorderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α` and\n`Ord α` instances as well as an `IsLinearPreorder α` instance and `LawfulOrder*` instances proving\nthe compatibility of the operations with the linear preorder.\n\nIn the presence of `Ord α` and `TransOrd α` instances, no arguments are required and the factory can\nbe used as in this example:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofOrd X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofOrd X {\n  ord := sorry\n  transOrd := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearPreorderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearPreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearPreorderOfOrdArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq` and `Ord`, existing instances are always\n  preferred. If no existing instances can be synthesized, it is attempted to derive an instance from\n  the `Ord` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `Ord` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `Ord α` instance. In this case, `beq_iff`\n  can be omitted because Lean can infer that `BEq α` and `Ord α` are compatible.\n* Other proof obligations, for example `transOrd`, can be omitted if a matching instance can be\n  synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofOrd","kind":"def","line":602,"name":"Std.LinearPreorderPackage.ofOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L602-L668"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">beq_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq\">beq</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq_iff","kind":"theorem","line":592,"name":"Std.Packages.LinearPreorderOfOrdArgs.beq_iff","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L592-L592"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">beq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.beq","kind":"def","line":586,"name":"Std.Packages.LinearPreorderOfOrdArgs.beq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L586-L586"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\">lt</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLT","kind":"def","line":576,"name":"Std.Packages.LinearPreorderOfOrdArgs.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L576-L576"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lt_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\">lt</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt_iff","kind":"theorem","line":567,"name":"Std.Packages.LinearPreorderOfOrdArgs.lt_iff","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L567-L567"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lt","kind":"def","line":560,"name":"Std.Packages.LinearPreorderOfOrdArgs.lt","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L560-L560"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.decidableLE","kind":"def","line":550,"name":"Std.Packages.LinearPreorderOfOrdArgs.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L550-L550"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">lawfulOrderOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\">le</a></span>;\n<span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd","kind":"theorem","line":541,"name":"Std.Packages.LinearPreorderOfOrdArgs.lawfulOrderOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L541-L541"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\">ord</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.le","kind":"def","line":534,"name":"Std.Packages.LinearPreorderOfOrdArgs.le","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L534-L534"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">transOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.TransOrd\">TransOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.transOrd","kind":"theorem","line":533,"name":"Std.Packages.LinearPreorderOfOrdArgs.transOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L533-L533"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">ord</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.ord","kind":"def","line":532,"name":"Std.Packages.LinearPreorderOfOrdArgs.ord","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L532-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ord</span> : <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.TransOrd\">TransOrd</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.LE.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lawfulOrderOrd</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">transOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  |\n    fail &quot;Failed to automatically derive a `LawfulOrderOrd` instance. \\\n                  Please ensure that the instance can be synthesized or \\\n                  manually provide the field `lawfulOrderOrd`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.DecidableLE.ofOrd _\n  |\n    fail &quot;Failed to automatically derive that `LE` is decidable.\\\n                  Please ensure that a `DecidableLE` instance can be synthesized or \\\n                  manually provide the field `decidableLE`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact LT.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun _ _ =&gt; _root_.Std.compare_eq_lt.symm\n  |\n    fail &quot;Failed to automatically derive that `LT` and `Ord` are compatible. \\\n                  Please ensure that a `LawfulOrderLT` instance can be synthesized or \\\n                  manually provide the field `lt_iff`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_3</span> := <span class=\"fn\">lt_iff</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_DecidableLT.ofOrd _\n  |\n    fail &quot;Failed to automatically derive that `LT` is decidable. \\\n                  Please ensure that a `DecidableLT` instance can be synthesized or \\\n                  manually provide the field `decidableLT`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.BEq.ofOrd _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">lawfulOrderOrd</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">beq</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <a href=\"./Init/Data/Ord/Basic.html#Ordering.eq\">Ordering.eq</a></span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun _ _ =&gt; Std.compare_eq_eq.symm\n  |\n    fail &quot;Failed to automatically derive that `BEq` and `Ord` are compatible. \\\n                  Please ensure that a `LawfulOrderBEq` instance can be synthesized or \\\n                  manually provide the field `beq_iff`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\">LinearPreorderOfOrdArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs.mk","kind":"ctor","line":531,"name":"Std.Packages.LinearPreorderOfOrdArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L531-L531"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfOrdArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearPreorderPackage α` instance.\nIts fields are automatically provided if possible. For the detailed rules how the fields are\ninferred, see `LinearPreorderPackage.ofOrd`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfOrdArgs","kind":"structure","line":526,"name":"Std.Packages.LinearPreorderOfOrdArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L526-L600"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.OrientedCmp.of_gt_iff_lt\"><span class=\"name\">Std</span>.<span class=\"name\">OrientedCmp</span>.<span class=\"name\">of_gt_iff_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">cmp</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.gt\">Ordering.gt</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">cmp</span> <span class=\"fn\">b</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Data/Ord/Basic.html#Ordering.lt\">Ordering.lt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Ord.html#Std.OrientedCmp\">OrientedCmp</a> <span class=\"fn\">cmp</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.OrientedCmp.of_gt_iff_lt","kind":"theorem","line":511,"name":"Std.OrientedCmp.of_gt_iff_lt","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L511-L522"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">Packages.LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear order on a type `α` and all the associated\noperations and instances given an `LE α` instance.\n\nCreates a `LinearOrderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α`,\n`Ord α`, `Min α` and `Max α` instances as well as an `IsLinearOrder α` instance and `LawfulOrder*`\ninstances proving the compatibility of the operations with the linear order.\n\nIn the presence of `LE α`, `DecidableLE α`, `Total (· ≤ ·)`, `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)` and\n`Antisymm (· ≤ ·)` instances, no arguments are required and the factory can be used as in this\nexample:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearOrderPackage X := .ofLE X {\n  le_total := sorry\n  le_trans := sorry\n  le_antisymm := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearOrderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearOrderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearOrderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq`, `Ord`, `Min` and `Max`, existing instances\n  are always preferred. If no existing instances can be synthesized, it is attempted to derive an\n  instance from the `LE` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can be\n  omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_total`, `le_trans` and `le_antisymm`, can be omitted if\n  `Total`, `Trans` and `Antisymm` instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.ofLE","kind":"def","line":440,"name":"Std.LinearOrderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L440-L501"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">max_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max\">max</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max_eq","kind":"theorem","line":430,"name":"Std.Packages.LinearOrderOfLEArgs.max_eq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L430-L430"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min_eq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">min_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min\">min</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min_eq","kind":"theorem","line":421,"name":"Std.Packages.LinearOrderOfLEArgs.min_eq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L421-L421"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">max</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.max","kind":"def","line":414,"name":"Std.Packages.LinearOrderOfLEArgs.max","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L414-L414"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">min</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.min","kind":"def","line":407,"name":"Std.Packages.LinearOrderOfLEArgs.min","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L407-L407"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.le_antisymm","kind":"theorem","line":406,"name":"Std.Packages.LinearOrderOfLEArgs.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L406-L406"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toLinearPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.Antisymm.antisymm\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is antisymmetric. \\\n                  Please ensure that a `Antisymm` instance can be synthesized or \\\n                  manually provide the field `le_antisymm`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Min.leftLeaningOfLE _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Max.leftLeaningOfLE _)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">min_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">min</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">Min.min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a>         <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun a b =&gt; _root_.Std.min_eq_if (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `min` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMin` instance can be synthesized or \\\n                  manually provide the field `min_eq`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">max_eq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toLinearPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">max</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">Max.max</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#ite\">if</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">then</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#ite\">else</a>         <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun a b =&gt; _root_.Std.max_eq_if (a := a) (b := b)\n  |\n    fail &quot;Failed to automatically prove that `max` is left-leaning. \\\n                  Please ensure that a `LawfulOrderLeftLeaningMax` instance can be synthesized or \\\n                  manually provide the field `max_eq`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.mk","kind":"ctor","line":405,"name":"Std.Packages.LinearOrderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L405-L405"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">toLinearPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs","kind":"def","line":405,"name":"Std.Packages.LinearOrderOfLEArgs.toLinearPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L405-L438"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span>.<span class=\"name\">toPartialOrderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\">LinearOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs","kind":"def","line":405,"name":"Std.Packages.LinearOrderOfLEArgs.toPartialOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L405-L438"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearOrderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">Std.Packages.LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">Std.Packages.PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearOrderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`LinearOrderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearOrderOfLEArgs","kind":"structure","line":400,"name":"Std.Packages.LinearOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L400-L438"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.le_antisymm","kind":"theorem","line":397,"name":"Std.LinearOrderPackage.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L397-L397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLinearPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toMin</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toMax</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderMin</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">LawfulOrderMin</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderMax</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">LawfulOrderMax</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.mk","kind":"ctor","line":396,"name":"Std.LinearOrderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L396"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMax\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLawfulOrderMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">LawfulOrderMax</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMax","kind":"theorem","line":396,"name":"Std.LinearOrderPackage.toLawfulOrderMax","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMin\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLawfulOrderMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">LawfulOrderMin</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLawfulOrderMin","kind":"theorem","line":396,"name":"Std.LinearOrderPackage.toLawfulOrderMin","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMax\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMax","kind":"def","line":396,"name":"Std.LinearOrderPackage.toMax","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMin\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toMin","kind":"def","line":396,"name":"Std.LinearOrderPackage.toMin","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toPartialOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toPartialOrderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toPartialOrderPackage","kind":"def","line":396,"name":"Std.LinearOrderPackage.toPartialOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toIsLinearOrder\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toIsLinearOrder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearOrder\">IsLinearOrder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toIsLinearOrder","kind":"theorem","line":396,"name":"Std.LinearOrderPackage.toIsLinearOrder","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLinearPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span>.<span class=\"name\">toLinearPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\">LinearOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage.toLinearPreorderPackage","kind":"def","line":396,"name":"Std.LinearOrderPackage.toLinearPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L396-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearOrderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">Std.LinearPreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">Std.PartialOrderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#Min\">Min</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#Max\">Max</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMin\">Std.LawfulOrderMin</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderMax\">Std.LawfulOrderMax</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearOrder\">Std.IsLinearOrder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α`, `BEq α`, `Ord α`, `Min α` and `Max α` instances as well as proofs\nthat these operations represent the same linear order structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearOrderPackage","kind":"class","line":392,"name":"Std.LinearOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L392-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">Packages.LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a linear preorder on a type `α` and all the associated\noperations and instances given an `LE α` instance.\n\nCreates a `LinearPreorderPackage α` instance. Such an instance entails `LE α`, `LT α`, `BEq α` and\n`Ord α` instances as well as an `IsLinearPreorder α` instance and `LawfulOrder*` instances proving\nthe compatibility of the operations with the linear preorder.\n\nIn the presence of `LE α`, `DecidableLE α`, `Total (· ≤ ·)` and `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)`\ninstances, no arguments are required and the factory can be used as in this example:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : LinearPreorderPackage X := .ofLE X {\n  le_total := sorry\n  le_trans := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `LinearPreorderPackage`. This\ncan be useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`LinearPreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.LinearPreorderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT`, `BEq` and `Ord`, existing instances are always\n  preferred. If no existing instances can be synthesized, it is attempted to derive an instance from\n  the `LE` instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can be\n  omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_total` and `le_trans`, can be omitted if `Total` and `Trans`\n  instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.ofLE","kind":"def","line":340,"name":"Std.LinearPreorderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L340-L390"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isGE_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">isGE_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\">ord</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isGE_compare","kind":"theorem","line":330,"name":"Std.Packages.LinearPreorderOfLEArgs.isGE_compare","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L330-L330"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isLE_compare\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">isLE_compare</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\">ord</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.isLE_compare","kind":"theorem","line":321,"name":"Std.Packages.LinearPreorderOfLEArgs.isLE_compare","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L321-L321"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.le_total\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">le_total</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.le_total","kind":"theorem","line":313,"name":"Std.Packages.LinearPreorderOfLEArgs.le_total","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L313-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">ord</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.ord","kind":"def","line":306,"name":"Std.Packages.LinearPreorderOfLEArgs.ord","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L306-L306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ord</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.instOrdOfDecidableLE)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_total</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span> := by\n  first\n  | exact _root_.Std.Total.total\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is total. \\\n                  Please ensure that a `Total` instance can be synthesized or \\\n                  manually provide the field `le_total`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isLE_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isLE\">isLE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.LawfulOrderOrd.isLE_compare\n  |\n    fail &quot;Failed to automatically prove that `(compare a b).isLE` is equivalent to `a ≤ b`. \\\n                  Please ensure that a `LawfulOrderOrd` instance can be synthesized or \\\n                  manually provide the field `isLE_compare`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isGE_compare</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n  <span class=\"fn\">have <span class=\"fn\">this_2</span> := <span class=\"fn\">le_total</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_3</span> := <span class=\"fn\">ord</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span>.<a href=\"./Init/Data/Ord/Basic.html#Ordering.isGE\">isGE</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.LawfulOrderOrd.isGE_compare\n  |\n    fail &quot;Failed to automatically prove that `(compare a b).isGE` is equivalent to `b ≤ a`. \\\n                  Please ensure that a `LawfulOrderOrd` instance can be synthesized or \\\n                  manually provide the field `isGE_compare`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.mk","kind":"ctor","line":304,"name":"Std.Packages.LinearPreorderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L304-L304"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span>.<span class=\"name\">toPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\">LinearPreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs","kind":"def","line":304,"name":"Std.Packages.LinearPreorderOfLEArgs.toPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L304-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">LinearPreorderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Std.Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `LinearPreorderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`LinearPreorderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.LinearPreorderOfLEArgs","kind":"structure","line":299,"name":"Std.Packages.LinearPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L299-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">le_total</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.le_total","kind":"theorem","line":297,"name":"Std.LinearPreorderPackage.le_total","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L297-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderOrd</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_total</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.mk","kind":"ctor","line":296,"name":"Std.LinearPreorderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L296-L296"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toOrd","kind":"def","line":296,"name":"Std.LinearPreorderPackage.toOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toPreorderPackage","kind":"def","line":296,"name":"Std.LinearPreorderPackage.toPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toLawfulOrderOrd\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toLawfulOrderOrd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toLawfulOrderOrd","kind":"theorem","line":296,"name":"Std.LinearPreorderPackage.toLawfulOrderOrd","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toIsLinearPreorder\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span>.<span class=\"name\">toIsLinearPreorder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\">LinearPreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearPreorder\">IsLinearPreorder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage.toIsLinearPreorder","kind":"theorem","line":296,"name":"Std.LinearPreorderPackage.toIsLinearPreorder","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">LinearPreorderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">Std.PreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">Std.LawfulOrderOrd</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsLinearPreorder\">Std.IsLinearPreorder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α`, `BEq α` and `Ord α` instances as well as proofs that these\noperations represent the same linear preorder structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.LinearPreorderPackage","kind":"class","line":292,"name":"Std.LinearPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L292-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderOrdOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Std.Total\">Total</a> <span class=\"fn\">fun (<span class=\"fn\">x1</span> <span class=\"fn\">x2</span> : <span class=\"fn\">α</span>) =&gt; <span class=\"fn\">x1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x2</span></span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/ClassesExtra.html#Std.LawfulOrderOrd\">LawfulOrderOrd</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","kind":"instance","line":284,"name":"Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L284-L288"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instOrdOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instOrdOfDecidableLE","kind":"def","line":264,"name":"Std.FactoryInstances.instOrdOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L264-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">Packages.PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.ofLE","kind":"def","line":254,"name":"Std.PartialOrderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L254-L258"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.le_antisymm","kind":"theorem","line":199,"name":"Std.Packages.PartialOrderOfLEArgs.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L199-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">toPreorderOfLEArgs</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">toPreorderOfLEArgs</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.Antisymm.antisymm\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is antisymmetric. \\\n                  Please ensure that a `Antisymm` instance can be synthesized or \\\n                  manually provide the field `le_antisymm`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.mk","kind":"ctor","line":198,"name":"Std.Packages.PartialOrderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L198-L198"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span>.<span class=\"name\">toPreorderOfLEArgs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\">PartialOrderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs","kind":"def","line":198,"name":"Std.Packages.PartialOrderOfLEArgs.toPreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L198-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PartialOrderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Std.Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `PartialOrderPakckage α` instance. Its\nfields are automatically provided if possible. For the detailed rules how the fields are inferred,\nsee `PartialOrderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PartialOrderOfLEArgs","kind":"structure","line":193,"name":"Std.Packages.PartialOrderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L193-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">le_antisymm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.le_antisymm","kind":"theorem","line":191,"name":"Std.PartialOrderPackage.le_antisymm","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L191-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toPreorderPackage</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_antisymm</span> : <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.mk","kind":"ctor","line":190,"name":"Std.PartialOrderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L190-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toIsPartialOrder\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">toIsPartialOrder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPartialOrder\">IsPartialOrder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toIsPartialOrder","kind":"theorem","line":190,"name":"Std.PartialOrderPackage.toIsPartialOrder","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L190-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toPreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span>.<span class=\"name\">toPreorderPackage</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\">PartialOrderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage.toPreorderPackage","kind":"def","line":190,"name":"Std.PartialOrderPackage.toPreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L190-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PartialOrderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">Std.PreorderPackage</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPartialOrder\">Std.IsPartialOrder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α` and `BEq α` instances as well as proofs that these operations\nrepresent the same partial order structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PartialOrderPackage","kind":"class","line":186,"name":"Std.PartialOrderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L186-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">ofLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">Packages.PreorderOfLEArgs</a> <span class=\"fn\">α</span></span> := by exact { })</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Use this factory to conveniently define a preorder on a type `α` and all the associated operations\nand instances given an `LE α` instance.\n\nCreates a `PreorderPackage α` instance. Such an instance entails `LE α`, `LT α` and\n`BEq α` instances as well as an `IsPreorder α` instance and `LawfulOrder*` instances proving the\ncompatibility of the operations with the preorder.\n\nIn the presence of `LE α`, `DecidableLE α`, `Refl (· ≤ ·)` and `Trans (· ≤ ·) (· ≤ ·) (· ≤ ·)`\ninstances, no arguments are required and the factory can be used as in this example:\n\n```lean\npublic instance : PreorderPackage X := .ofLE X\n```\n\nIf not all of these instances are available via typeclass synthesis, it is necessary to explicitly\nprovide some arguments:\n\n```lean\npublic instance : PreorderPackage X := .ofLE X {\n  le_refl := sorry\n  le_trans := sorry }\n```\n\nIt is also possible to do all of this by hand, without resorting to `PreorderPackage`. This can\nbe useful if, say, one wants to avoid specifying an `LT α` instance, which is not possible with\n`PreorderPackage`.\n\n**How the arguments are filled**\n\nLean tries to fill all of the fields of the `args : Packages.PreorderOfLEArgs α` parameter\nautomatically. If it fails, it is necessary to provide some of the fields manually.\n\n* For the data-carrying typeclasses `LE`, `LT` and `BEq`, existing instances are always preferred.\n  If no existing instances can be synthesized, it is attempted to derive an instance from the `LE`\n  instance.\n* Some proof obligations can be filled automatically if the data-carrying typeclasses have been\n  derived from the `LE` instance. For example: If the `beq` field is omitted and no `BEq α` instance\n  can be synthesized, it is derived from the `LE α` instance. In this case, `beq_iff_le_and_ge` can\n  be omitted because Lean can infer that `BEq α` and `LE α` are compatible.\n* Other proof obligations, namely `le_refl` and `le_trans`, can be omitted if `Refl` and `Trans`\n  instances can be synthesized.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.ofLE","kind":"def","line":126,"name":"Std.PreorderPackage.ofLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L126-L180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_trans","kind":"theorem","line":116,"name":"Std.Packages.PreorderOfLEArgs.le_trans","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L116-L116"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le_refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le_refl","kind":"theorem","line":107,"name":"Std.Packages.PreorderOfLEArgs.le_refl","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L107-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">beq_iff_le_and_ge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq\">beq</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge","kind":"theorem","line":98,"name":"Std.Packages.PreorderOfLEArgs.beq_iff_le_and_ge","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L98-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\">lt</a></span>;\n<span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">⋯</span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLT","kind":"def","line":86,"name":"Std.Packages.PreorderOfLEArgs.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L86-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">lt_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\">lt</a></span>;\n<span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt_iff","kind":"theorem","line":77,"name":"Std.Packages.PreorderOfLEArgs.lt_iff","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L77-L77"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">beq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\">decidableLE</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.beq","kind":"def","line":70,"name":"Std.Packages.PreorderOfLEArgs.beq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L70-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\">le</a></span>;\n<span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.lt","kind":"def","line":63,"name":"Std.Packages.PreorderOfLEArgs.lt","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L63-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.decidableLE","kind":"def","line":62,"name":"Std.Packages.PreorderOfLEArgs.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L62-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.le","kind":"def","line":61,"name":"Std.Packages.PreorderOfLEArgs.le","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L61-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span> := by infer_instance)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Classical.Order.instLT)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></span></span> := by\n  extract_lets\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.beqOfDecidableLE)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt_iff</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.LawfulOrderLT.lt_iff\n  |\n    fail &quot;Failed to automatically prove that the `LE` and `LT` instances are compatible. \\\n                  Please ensure that a `LawfulOrderLT` instance can be synthesized or \\\n                  manually provide the field `lt_iff`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">lt</span>;\n  <span class=\"fn\">have <span class=\"fn\">this_1</span> := <span class=\"fn\">lt_iff</span>;\n  <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></span></span></span></span> := by\n  extract_lets\n  haveI := @_root_.Std.LawfulOrderLT.mk (lt_iff := by assumption) ..\n  first\n  | infer_instance\n  | exact _root_.Std.FactoryInstances.decidableLTOfLE\n  |\n    fail &quot;Failed to automatically derive that `LT` is decidable. \\\n                  Please ensure that a `DecidableLT` instance can be synthesized or \\\n                  manually provide the field `decidableLT`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">beq_iff_le_and_ge</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_1</span> := <span class=\"fn\">decidableLE</span>;\n  <span class=\"fn\">let <span class=\"fn\">this_2</span> := <span class=\"fn\">beq</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>), (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#BEq.beq\">==</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.LawfulOrderBEq.beq_iff_le_and_ge\n  |\n    fail &quot;Failed to automatically prove that the `LE` and `BEq` instances are compatible. \\\n                    Please ensure that a `LawfulOrderBEq` instance can be synthesized or \\\n                    manually provide the field `beq_iff_le_and_ge`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_refl</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>), <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></span></span> := by\n  extract_lets\n  first\n  | exact _root_.Std.Refl.refl (r := (· ≤ ·))\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is reflexive. \\\n                  Please ensure that a `Refl` instance can be synthesized or \\\n                  manually provide the field `le_refl`.&quot;)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">le_trans</span> :\n  <span class=\"fn\">let <span class=\"fn\">this</span> := <span class=\"fn\">le</span>;\n  <span class=\"fn\">∀ (<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span></span></span></span></span> := by\n  extract_lets\n  first\n  | exact fun _ _ _ hab hbc =&gt; _root_.Trans.trans (r := (· ≤ ·)) (s := (· ≤ ·)) (t := (· ≤ ·)) hab hbc\n  |\n    fail &quot;Failed to automatically prove that the `LE` instance is transitive. \\\n                  Please ensure that a `Trans` instance can be synthesized or \\\n                  manually provide the field `le_trans`.&quot;)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\">PreorderOfLEArgs</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs.mk","kind":"ctor","line":60,"name":"Std.Packages.PreorderOfLEArgs.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L60-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Packages</span>.<span class=\"name\">PreorderOfLEArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This structure contains all the data needed to create a `PreorderPackage α` instance. Its fields\nare automatically provided if possible. For the detailed rules how the fields are inferred, see\n`PreorderPackage.ofLE`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.Packages.PreorderOfLEArgs","kind":"structure","line":55,"name":"Std.Packages.PreorderOfLEArgs","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L55-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">decidableLTOfLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x✝</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"If `LT` can be characterized in terms of a decidable `LE`, then `LT` is decidable either. ","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.decidableLTOfLE","kind":"def","line":45,"name":"Std.FactoryInstances.decidableLTOfLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L45-L51"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">instLawfulOrderBEqOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","kind":"instance","line":41,"name":"Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L41-L43"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">FactoryInstances</span>.<span class=\"name\">beqOfDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.FactoryInstances.beqOfDecidableLE","kind":"def","line":37,"name":"Std.FactoryInstances.beqOfDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L37-L39"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.instDecidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">instDecidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.instDecidableLT","kind":"instance","line":33,"name":"Std.instDecidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L33-L33"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.instDecidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">instDecidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.instDecidableLE","kind":"instance","line":32,"name":"Std.instDecidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">decidableLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLT","kind":"def","line":30,"name":"Std.PreorderPackage.decidableLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">decidableLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.decidableLE","kind":"def","line":29,"name":"Std.PreorderPackage.decidableLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L29-L29"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.mk\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLT</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toBEq</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderLT</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toLawfulOrderBEq</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">toIsPreorder</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">IsPreorder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLE</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decidableLT</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.mk","kind":"ctor","line":27,"name":"Std.PreorderPackage.mk","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L27"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderBEq\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLawfulOrderBEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">LawfulOrderBEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderBEq","kind":"theorem","line":27,"name":"Std.PreorderPackage.toLawfulOrderBEq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toBEq\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toBEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toBEq","kind":"def","line":27,"name":"Std.PreorderPackage.toBEq","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLT","kind":"def","line":27,"name":"Std.PreorderPackage.toLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toIsPreorder\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toIsPreorder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">IsPreorder</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toIsPreorder","kind":"theorem","line":27,"name":"Std.PreorderPackage.toIsPreorder","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderLT\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLawfulOrderLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">LawfulOrderLT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLawfulOrderLT","kind":"theorem","line":27,"name":"Std.PreorderPackage.toLawfulOrderLT","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLE\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span>.<span class=\"name\">toLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\">PreorderPackage</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage.toLE","kind":"def","line":27,"name":"Std.PreorderPackage.toLE","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L27-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage\"><span class=\"name\">Std</span>.<span class=\"name\">PreorderPackage</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_extends\">extends</span> <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderLT\">Std.LawfulOrderLT</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.LawfulOrderBEq\">Std.LawfulOrderBEq</a> <span class=\"fn\">α</span></span>, <span class=\"fn\"><a href=\"./Init/Data/Order/Classes.html#Std.IsPreorder\">Std.IsPreorder</a> <span class=\"fn\">α</span></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"This class entails `LE α`, `LT α` and `BEq α` instances as well as proofs that these operations\nrepresent the same preorder structure on `α`.\n","docLink":"./Init/Data/Order/PackageFactories.html#Std.PreorderPackage","kind":"class","line":23,"name":"Std.PreorderPackage","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Init/Data/Order/PackageFactories.lean#L23-L30"}}],"imports":["Init.Data.Order.LemmasExtra"],"instances":[{"className":"Decidable","name":"Std.instDecidableLE","typeNames":["LE.le"]},{"className":"Decidable","name":"Std.instDecidableLT","typeNames":["LT.lt"]},{"className":"Std.LawfulOrderBEq","name":"Std.FactoryInstances.instLawfulOrderBEqOfDecidableLE","typeNames":[]},{"className":"Std.LawfulOrderOrd","name":"Std.FactoryInstances.instLawfulOrderOrdOfDecidableLE","typeNames":[]},{"className":"Std.LawfulOrderLeftLeaningMin","name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMinOfOrd","typeNames":[]},{"className":"Std.LawfulOrderLeftLeaningMax","name":"Std.FactoryInstances.instLawfulOrderLeftLeaningMaxOfOrd","typeNames":[]}],"name":"Init.Data.Order.PackageFactories"}