{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">erasePatternRefAnnotations</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","kind":"def","line":255,"name":"Lean.Meta.erasePatternRefAnnotations","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L255-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eraseInaccessibleAnnotations</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","kind":"def","line":252,"name":"Lean.Meta.eraseInaccessibleAnnotations","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L252-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.unfoldIfArgIsAppOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">unfoldIfArgIsAppOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnNames</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">numSectionVars</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Unfolds theorems that are applied to a `f x₁ .. xₙ` where `f` is in the given array, and\n`n ≤ SectionVars`, i.e. an unsaturated application of `f`.\n\nThis is used tounfoldIfArgIsAppOf undo proof abstraction for termination checking, as otherwise the bare\noccurrence of the recursive function prevents termination checking from succeeding.\n\nUsually, the argument is just `f` (the constant), arising from `mkAuxTheorem` abstracting over the\naux decl representing `f`. If the mutual function is defined within the scope of `variable` commands,\nit is `f x y` where `x y` are the variables in scope, so we use the `numSectionVars` to recognize that\nwhile avoiding to unfold theorems applied to saturated applications of `f`.\n\nThis unfolds from the private environment. The resulting definitions are (usually) not\nexposed anyways.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldIfArgIsAppOf","kind":"def","line":209,"name":"Lean.Meta.unfoldIfArgIsAppOf","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L209-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">unfoldDeclsFrom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">biggerEnv</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. ","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","kind":"def","line":190,"name":"Lean.Meta.unfoldDeclsFrom","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L190-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.zetaDeltaFVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">zetaDeltaFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Zeta reduces only the provided fvars, beta reducing the substitutions.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaDeltaFVars","kind":"def","line":175,"name":"Lean.Meta.zetaDeltaFVars","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L175-L188"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">zetaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","kind":"def","line":167,"name":"Lean.Meta.zetaReduce","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L167-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.transform\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">transform</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">usedLetOnly </span><span class=\"fn\">skipConstInApp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`.\n\nWarning: `pre` and `post` should not depend on variables in the local context introduced by `transform`.\nThis is in order to allow aggressive caching.\n\nIf `skipConstInApp := true`, then for an expression `mkAppN (.const f) args`, the subexpression\n`.const f` is not visited again. Put differently: every `.const f` is visited once, with its\narguments if present, on its own otherwise.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","kind":"def","line":145,"name":"Lean.Meta.transform","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L145-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Meta.transformWithCache\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">transformWithCache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cache</span> : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.ExprStructEq\">ExprStructEq</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">usedLetOnly </span><span class=\"fn\">skipConstInApp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> (<a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Lean/Expr.html#Lean.ExprStructEq\">ExprStructEq</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></div></div>","info":{"doc":"Similar to `Meta.transform`, but allows the use of a pre-existing cache.\n\nWarnings:\n- For the cache to be valid, it must always use the same `pre` and `post` functions.\n- It is important that there are no other references to `cache` when it is passed to\n  `transformWithCache`, to avoid unnecessary copying of the hash map.\n","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transformWithCache","kind":"def","line":80,"name":"Lean.Meta.transformWithCache","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L80-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Core.betaReduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">betaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","kind":"def","line":73,"name":"Lean.Core.betaReduce","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L73-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.Core.transform\"><span class=\"name\">Lean</span>.<span class=\"name\">Core</span>.<span class=\"name\">transform</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Basic.html#MonadControlT\">MonadControlT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">input</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pre</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\">TransformStep.continue</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">post</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">(<a href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\">TransformStep.done</a> <span class=\"fn\">e</span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Transform the expression `input` using `pre` and `post`.\n- First `pre` is invoked with the current expression and recursion is continued according to the `TransformStep` result.\n  In all cases, the expression contained in the result, if any, must be definitionally equal to the current expression.\n- After recursion, if any, `post` is invoked on the resulting expression.\n\nThe term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\nif one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\nConsider using `Meta.transform` to avoid loose bound variables.\n\nThis method is useful for applying transformations such as beta-reduction and delta-reduction.\n","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","kind":"def","line":32,"name":"Lean.Core.transform","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L32-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instReprTransformStep.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">instReprTransformStep</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instReprTransformStep.repr","kind":"def","line":28,"name":"Lean.instReprTransformStep.repr","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instReprTransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">instReprTransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instReprTransformStep","kind":"instance","line":28,"name":"Lean.instReprTransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">instInhabitedTransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></span></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep","kind":"instance","line":28,"name":"Lean.instInhabitedTransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep.default\"><span class=\"name\">Lean</span>.<span class=\"name\">instInhabitedTransformStep</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.instInhabitedTransformStep.default","kind":"def","line":28,"name":"Lean.instInhabitedTransformStep.default","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.continue\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">continue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Continue transformation with the given expression (defaults to current expression).\nFor `pre`, this means visiting the children of the expression.\nFor `post`, this is equivalent to returning `done`. ","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.continue","kind":"ctor","line":23,"name":"Lean.TransformStep.continue","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L23-L27"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.visit\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">visit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Visit expression (which should be different from current expression) instead.\nThe new expression `e` is passed to `pre` again.\n","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.visit","kind":"ctor","line":18,"name":"Lean.TransformStep.visit","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L18-L22"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep.done\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span>.<span class=\"name\">done</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Transform.html#Lean.TransformStep\">TransformStep</a></div></div>","info":{"doc":"Return expression without visiting any subexpressions. ","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.done","kind":"ctor","line":16,"name":"Lean.TransformStep.done","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L16-L17"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Transform.html#Lean.TransformStep\"><span class=\"name\">Lean</span>.<span class=\"name\">TransformStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","kind":"inductive","line":15,"name":"Lean.TransformStep","sourceLink":"https://github.com/leanprover/lean4/blob/cdd38ac5115bdeec5f609e9126cce00f51ae88b3/src/Lean/Meta/Transform.lean#L15-L28"}}],"imports":["Lean.Meta.Basic"],"instances":[{"className":"Inhabited","name":"Lean.instInhabitedTransformStep","typeNames":["Lean.TransformStep"]},{"className":"Repr","name":"Lean.instReprTransformStep","typeNames":["Lean.TransformStep"]}],"name":"Lean.Meta.Transform"}