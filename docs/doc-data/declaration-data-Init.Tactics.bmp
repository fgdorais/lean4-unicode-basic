{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#autoParam\"><span class=\"name\">autoParam</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tactic</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Sort</a> u</div></div>","info":{"doc":"Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\nthe given tactic.\nLike `optParam`, this gadget only affects elaboration.\nFor example, the tactic will *not* be invoked during type class resolution. ","docLink":"./Init/Tactics.html#autoParam","kind":"def","line":2395,"name":"autoParam","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2395-L2400"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Syntax.exact?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Syntax</span>.<span class=\"name\">exact?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Searches environment for definitions or theorems that can be substituted in\nfor `exact?%` to solve the goal.\n ","docLink":"./Init/Tactics.html#Lean.Parser.Syntax.exact?","kind":"def","line":2388,"name":"Lean.Parser.Syntax.exact?","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2388-L2392"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#tacticGet_elem_tactic\"><span class=\"name\">tacticGet_elem_tactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_extensible` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_extensible` instead of this tactic.\n","docLink":"./Init/Tactics.html#tacticGet_elem_tactic","kind":"def","line":2356,"name":"tacticGet_elem_tactic","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2356-L2386"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#tacticGet_elem_tactic_trivial\"><span class=\"name\">tacticGet_elem_tactic_trivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`get_elem_tactic_trivial` has been deprecated in favour of `get_elem_tactic_extensible`. ","docLink":"./Init/Tactics.html#tacticGet_elem_tactic_trivial","kind":"def","line":2342,"name":"tacticGet_elem_tactic_trivial","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2342-L2343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#tacticGet_elem_tactic_extensible\"><span class=\"name\">tacticGet_elem_tactic_extensible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`get_elem_tactic_extensible` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to try `simp +arith` and `omega`\n(for doing linear arithmetic in the index).\n\n(Note that the core tactic `get_elem_tactic` has already tried\n`done` and `assumption` before the extensible tactic is called.)\n","docLink":"./Init/Tactics.html#tacticGet_elem_tactic_extensible","kind":"def","line":2330,"name":"tacticGet_elem_tactic_extensible","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2330-L2340"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#«term‹_›»\"><span class=\"name\">«term‹_›»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`‹t›` resolves to an (arbitrary) hypothesis of type `t`.\nIt is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type;\nin particular, `‹_›` is a shortcut for `by assumption`.\n","docLink":"./Init/Tactics.html#«term‹_›»","kind":"def","line":2321,"name":"«term‹_›»","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2321-L2327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Attr.norm_cast\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">norm_cast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `norm_cast` attribute should be given to lemmas that describe the\nbehaviour of a coercion with respect to an operator, a relation, or a particular\nfunction.\n\nIt only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of\nthe coercion functions.\nIt does not apply to the explicit functions that define the coercions.\n\nExamples:\n```lean\n@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n\n\n@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1\n\n@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n\n\n@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n\n\n@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n\n\n@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1\n```\n\nLemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and\n`squash`. They are classified roughly as follows:\n\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n\n`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression\nand to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean\nup the result.\n\nIt is typically not necessary to specify these categories, as `norm_cast` lemmas are\nautomatically classified by default. The automatic classification can be overridden by\ngiving an optional `elim`, `move`, or `squash` parameter to the attribute.\n\n```lean\n@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by\n  rw [← of_real_nat_cast, of_real_re]\n```\n\nDon't do this unless you understand what you are doing.\n","docLink":"./Init/Tactics.html#Lean.Parser.Attr.norm_cast","kind":"def","line":2268,"name":"Lean.Parser.Attr.norm_cast","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2268-L2314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Attr.normCastLabel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">normCastLabel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The possible `norm_cast` kinds: `elim`, `move`, or `squash`. ","docLink":"./Init/Tactics.html#Lean.Parser.Attr.normCastLabel","kind":"def","line":2265,"name":"Lean.Parser.Attr.normCastLabel","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2265-L2266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Attr.wf_preprocess\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">wf_preprocess</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined\nby well-founded recursion. They are applied to the function's body to add additional hypotheses,\nsuch as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with\n`xs.attach.map`. Also see `wfParam`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Attr.wf_preprocess","kind":"def","line":2257,"name":"Lean.Parser.Attr.wf_preprocess","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2257-L2263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Attr.simp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">simp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext <| Iff.intro (fun _ => trivial) (fun _ => Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d <;> rfl\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Attr.simp","kind":"def","line":2206,"name":"Lean.Parser.Attr.simp","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2206-L2255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mvcgenMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgenMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mvcgen` will break down a Hoare triple proof goal like `⦃P⦄ prog ⦃Q⦄` into verification conditions,\nprovided that all functions used in `prog` have specifications registered with `@[spec]`.\n\nA verification condition is an entailment in the stateful logic of `Std.Do.SPred`\nin which the original program `prog` no longer occurs.\nVerification conditions are introduced by the `mspec` tactic; see the `mspec` tactic for what they\nlook like.\nWhen there's no applicable `mspec` spec, `mvcgen` will try and rewrite an application\n`prog = f a b c` with the simp set registered via `@[spec]`.\n\nWhen used like `mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]`, `mvcgen` will additionally\n\n* add a Hoare triple specification `foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄` to `spec` set for a\n  function `foo` occurring in `prog`,\n* unfold a definition `def bar_def ... := ...` in `prog`,\n* unfold any method of the `instBEqFloat : BEq Float` instance in `prog`.\n* it will no longer substitute away `let`-expressions that occur at most once in `P`, `Q` or `prog`.\n\nFurthermore, `mvcgen` tries to close trivial verification conditions by `SPred.entails.rfl` or\nthe tactic sequence `try (mpure_intro; trivial)`. The variant `mvcgen_no_trivial` does not do this.\n\nFor debugging purposes there is also `mvcgen_step 42` which will do at most 42 VC generation\nsteps. This is useful for bisecting issues with the generated VCs.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mvcgenMacro","kind":"def","line":2200,"name":"Lean.Parser.Tactic.mvcgenMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2200-L2201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mspecMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspec` is an `apply`-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.\n\nGiven a stateful goal `H ⊢ₛ wp⟦prog⟧ Q'`, `mspec foo_spec` will instantiate\n`foo_spec : ... → ⦃P⦄ foo ⦃Q⦄`, match `foo` against `prog` and produce subgoals for\nthe verification conditions `?pre : H ⊢ₛ P` and `?post : Q ⊢ₚ Q'`.\n\n* If `prog = x >>= f`, then `mspec Specs.bind` is tried first so that `foo` is matched against `x`\n  instead. Tactic `mspec_no_bind` does not attempt to do this decomposition.\n* If `?pre` or `?post` follow by `.rfl`, then they are discharged automatically.\n* `?post` is automatically simplified into constituent `⊢ₛ` entailments on\n  success and failure continuations.\n* `?pre` and `?post.*` goals introduce their stateful hypothesis under an inaccessible name.\n  You can give it a name with the `mrename_i` tactic.\n* Any uninstantiated MVar arising from instantiation of `foo_spec` becomes a new subgoal.\n* If the target of the stateful goal looks like `fun s => _` then `mspec` will first `mintro ∀s`.\n* If `P` has schematic variables that can be instantiated by doing `mintro ∀s`, for example\n  `foo_spec : ∀(n:Nat), ⦃fun s => ⌜n = s⌝⦄ foo ⦃Q⦄`, then `mspec` will do `mintro ∀s` first to\n  instantiate `n = s`.\n* Right before applying the spec, the `mframe` tactic is used, which has the following effect:\n  Any hypothesis `Hᵢ` in the goal `h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T` that is\n  pure (i.e., equivalent to some `⌜φᵢ⌝`) will be moved into the pure context as `hᵢ:φᵢ`.\n\nAdditionally, `mspec` can be used without arguments or with a term argument:\n\n* `mspec` without argument will try and look up a spec for `x` registered with `@[spec]`.\n* `mspec (foo_spec blah ?bleh)` will elaborate its argument as a term with expected type\n  `⦃?P⦄ x ⦃?Q⦄` and introduce `?bleh` as a subgoal.\n  This is useful to pass an invariant to e.g., `Specs.forIn_list` and leave the inductive step\n  as a hole.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mspecMacro","kind":"def","line":2172,"name":"Lean.Parser.Tactic.mspecMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2172-L2173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mintroMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintroMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `intro`, but introducing stateful hypotheses into the stateful context of the `Std.Do.SPred`\nproof mode.\nThat is, given a stateful goal `(hᵢ : Hᵢ)* ⊢ₛ P → T`, `mintro h` transforms\ninto `(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T`.\n\nFurthermore, `mintro ∀s` is like `intro s`, but preserves the stateful goal.\nThat is, `mintro ∀s` brings the topmost state variable `s:σ` in scope and transforms\n`(hᵢ : Hᵢ)* ⊢ₛ T` (where the entailment is in `Std.Do.SPred (σ::σs)`) into\n`(hᵢ : Hᵢ s)* ⊢ₛ T s` (where the entailment is in `Std.Do.SPred σs`).\n\nBeyond that, `mintro` supports the full syntax of `mcases` patterns\n(`mintro pat = (mintro h; mcases h with pat`), and can perform multiple\nintroductions in sequence.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mintroMacro","kind":"def","line":2137,"name":"Lean.Parser.Tactic.mintroMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2137-L2138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mrefineMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefineMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `refine`, but operating on stateful `Std.Do.SPred` goals.\n```lean\nexample (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mrefineMacro","kind":"def","line":2118,"name":"Lean.Parser.Tactic.mrefineMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2118-L2119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mcasesMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Like `rcases`, but operating on stateful `Std.Do.SPred` goals.\nExample: Given a goal `h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R`,\n`mcases h with ⟨-, ⟨hq | hr⟩, hqr⟩` will yield two goals:\n`(hq : Q, hqr : Q → R) ⊢ₛ R` and `(hr : R) ⊢ₛ R`.\n\nThat is, `mcases h with pat` has the following semantics, based on `pat`:\n* `pat=□h'` renames `h` to `h'` in the stateful context, regardless of whether `h` is pure\n* `pat=⌜h'⌝` introduces `h' : φ`  to the pure local context if `h : ⌜φ⌝`\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`)\n* `pat=h'` is like `pat=⌜h'⌝` if `h` is pure\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`), otherwise it is like `pat=□h'`.\n* `pat=_` renames `h` to an inaccessible name\n* `pat=-` discards `h`\n* `⟨pat₁, pat₂⟩` matches on conjunctions and existential quantifiers and recurses via\n  `pat₁` and `pat₂`.\n* `⟨pat₁ | pat₂⟩` matches on disjunctions, matching the left alternative via `pat₁` and the right\n  alternative via `pat₂`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mcasesMacro","kind":"def","line":2102,"name":"Lean.Parser.Tactic.mcasesMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2102-L2103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mleaveMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mleaveMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Leaves the stateful proof mode of `Std.Do.SPred`, tries to eta-expand through all definitions\nrelated to the logic of the `Std.Do.SPred` and gently simplifies the resulting pure Lean\nproposition. This is often the right thing to do after `mvcgen` in order for automation to prove\nthe goal.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mleaveMacro","kind":"def","line":2079,"name":"Lean.Parser.Tactic.mleaveMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2079-L2080"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mstopMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstopMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Stops the stateful proof mode of `Std.Do.SPred`.\nThis will simply forget all the names given to stateful hypotheses and pretty-print\na bit differently.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mstopMacro","kind":"def","line":2069,"name":"Lean.Parser.Tactic.mstopMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2069-L2070"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mstartMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstartMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Start the stateful proof mode of `Std.Do.SPred`.\nThis will transform a stateful goal of the form `H ⊢ₛ T` into `⊢ₛ H → T`\nupon which `mintro` can be used to re-introduce `H` and give it a name.\nIt is often more convenient to use `mintro` directly, which will\ntry `mstart` automatically if necessary.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mstartMacro","kind":"def","line":2060,"name":"Lean.Parser.Tactic.mstartMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2060-L2061"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mspecializePureMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecializePureMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspecialize_pure` is like `mspecialize`, but it specializes a hypothesis from the\n*pure* context with hypotheses from either the pure or stateful context or pure terms.\n```lean\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by\n  mintro HQ\n  mspecialize_pure (hΨ (y + 1)) hP HQ => HΨ\n  mexact HΨ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mspecializePureMacro","kind":"def","line":2049,"name":"Lean.Parser.Tactic.mspecializePureMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2049-L2050"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mspecializeMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecializeMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mspecialize` is like `specialize`, but operating on a stateful `Std.Do.SPred` goal.\nIt specializes a hypothesis from the stateful context with hypotheses from either the pure\nor stateful context or pure terms.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mspecialize HPQ HP\n  mexact HPQ\n\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by\n  mintro HQ HΨ\n  mspecialize HΨ (y + 1) hP HQ\n  mexact HΨ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mspecializeMacro","kind":"def","line":2035,"name":"Lean.Parser.Tactic.mspecializeMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2035-L2036"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mrenameIMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrenameIMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mrename_i` is like `rename_i`, but names inaccessible stateful hypotheses in a `Std.Do.SPred` goal.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mrenameIMacro","kind":"def","line":2015,"name":"Lean.Parser.Tactic.mrenameIMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2015-L2016"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mrevertMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrevertMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mrevert` is like `revert`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrevert HR\n  mrevert HP\n  mintro HP'\n  mintro HR'\n  mexact HR'\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mrevertMacro","kind":"def","line":2008,"name":"Lean.Parser.Tactic.mrevertMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L2008-L2009"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mpureIntroMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpureIntroMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mpure_intro` operates on a stateful `Std.Do.SPred` goal of the form `P ⊢ₛ ⌜φ⌝`.\nIt leaves the stateful proof mode (thereby discarding `P`), leaving the regular goal `φ`.\n```lean\ntheorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mpureIntroMacro","kind":"def","line":1992,"name":"Lean.Parser.Tactic.mpureIntroMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1992-L1993"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mpureMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpureMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mpure` moves a pure hypothesis from the stateful context into the pure context.\n```lean\nexample (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by\n  mintro Hφ\n  mpure Hφ\n  mexact (ψ Hφ)\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mpureMacro","kind":"def","line":1979,"name":"Lean.Parser.Tactic.mpureMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1979-L1980"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mrightMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrightMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mright` is like `right`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mrightMacro","kind":"def","line":1966,"name":"Lean.Parser.Tactic.mrightMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1966-L1967"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mleftMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mleftMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mleft` is like `left`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mleftMacro","kind":"def","line":1953,"name":"Lean.Parser.Tactic.mleftMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1953-L1954"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mreplaceMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mreplaceMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mreplace` is like `replace`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HPQ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mreplaceMacro","kind":"def","line":1940,"name":"Lean.Parser.Tactic.mreplaceMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1940-L1941"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mhaveMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mhaveMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mhave` is like `have`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HQ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mhaveMacro","kind":"def","line":1927,"name":"Lean.Parser.Tactic.mhaveMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1927-L1928"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mframeMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mframeMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mframe` infers which hypotheses from the stateful context can be moved into the pure context.\nThis is useful because pure hypotheses \"survive\" the next application of modus ponens\n(`Std.Do.SPred.mp`) and transitivity (`Std.Do.SPred.entails.trans`).\n\nIt is used as part of the `mspec` tactic.\n\n```lean\nexample (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by\n  mintro _\n  mframe\n  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/\n  mcases h with hP\n  mexact h\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mframeMacro","kind":"def","line":1914,"name":"Lean.Parser.Tactic.mframeMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1914-L1915"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mexistsMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexistsMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexists` is like `exists`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mexistsMacro","kind":"def","line":1894,"name":"Lean.Parser.Tactic.mexistsMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1894-L1895"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mexfalsoMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexfalsoMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexfalso` is like `exfalso`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mexfalsoMacro","kind":"def","line":1882,"name":"Lean.Parser.Tactic.mexfalsoMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1882-L1883"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mexactMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexactMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mexact` is like `exact`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mexactMacro","kind":"def","line":1869,"name":"Lean.Parser.Tactic.mexactMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1869-L1870"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mconstructorMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mconstructorMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mconstructor` is like `constructor`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor <;> mexact HQ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mconstructorMacro","kind":"def","line":1856,"name":"Lean.Parser.Tactic.mconstructorMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1856-L1857"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.mclearMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mclearMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`mclear` is like `clear`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q → Q := by\n  mintro HP\n  mintro HQ\n  mclear HP\n  mexact HQ\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.mclearMacro","kind":"def","line":1844,"name":"Lean.Parser.Tactic.mclearMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1844-L1845"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.massumptionMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">massumptionMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`massumption` is like `assumption`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.massumptionMacro","kind":"def","line":1830,"name":"Lean.Parser.Tactic.massumptionMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1830-L1831"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.bvNormalizeMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">bvNormalizeMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic\n`BitVec` goals already.\n\nNote: include `import Std.Tactic.BVDecide`\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.bvNormalizeMacro","kind":"def","line":1818,"name":"Lean.Parser.Tactic.bvNormalizeMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1818-L1819"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.bvTraceMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">bvTraceMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.\n\nNote: include `import Std.Tactic.BVDecide`\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.bvTraceMacro","kind":"def","line":1808,"name":"Lean.Parser.Tactic.bvTraceMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1808-L1809"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.bvDecideMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">bvDecideMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and\nverifying it inside Lean. The solvable goals are currently limited to\n- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)\n- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`\n```lean\nexample : ∀ (a b : BitVec 64), (a &&& b) + (a ^^^ b) = a ||| b := by\n  intros\n  bv_decide\n```\n\nIf `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`\nvariable. Sometimes this enables solving goals despite not understanding the definition because\nthe precise properties of the definition do not matter in the specific proof.\n\nIf `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all\nterms that were considered as variables.\n\nIn order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.\n\nIf solving your problem relies inherently on using associativity or commutativity, consider enabling\nthe `bv.ac_nf` option.\n\n\nNote: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.\n\nNote: include `import Std.Tactic.BVDecide`\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.bvDecideMacro","kind":"def","line":1799,"name":"Lean.Parser.Tactic.bvDecideMacro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1799-L1800"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.suggestPremises\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">suggestPremises</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`#suggest_premises` will suggest premises for the current goal, using the currently registered premise selector.\n\nThe suggestions are printed in the order of their confidence, from highest to lowest.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.suggestPremises","kind":"def","line":1764,"name":"Lean.Parser.Tactic.suggestPremises","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1764-L1769"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.exposeNames\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">exposeNames</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`expose_names` renames all inaccessible variables with accessible names, making them available\nfor reference in generated tactics. However, this renaming introduces machine-generated names\nthat are not fully under user control. `expose_names` is primarily intended as a preamble for\nauto-generated end-game tactic scripts. It is also useful as an alternative to\n`set_option tactic.hygienic false`. If explicit control over renaming is needed in the\nmiddle of a tactic script, consider using structured tactic scripts with\n`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,\nas well as tactics such as `next`, `case`, and `rename_i`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.exposeNames","kind":"def","line":1752,"name":"Lean.Parser.Tactic.exposeNames","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1752-L1762"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.by?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">by?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The command `by?` will print a suggestion for replacing the proof block with a proof term\nusing `show_term`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.by?","kind":"def","line":1750,"name":"Lean.Parser.Tactic.by?","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1750-L1750"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.showTermElab\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">showTermElab</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`show_term e` elaborates `e`, then prints the generated term.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.showTermElab","kind":"def","line":1743,"name":"Lean.Parser.Tactic.showTermElab","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1743-L1744"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.showTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">showTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" (prefixed by `expose_names` if necessary)\nif there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.showTerm","kind":"def","line":1731,"name":"Lean.Parser.Tactic.showTerm","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1731-L1738"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rewrites?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rewrites?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rewrites?","kind":"def","line":1720,"name":"Lean.Parser.Tactic.rewrites?","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1720-L1729"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rewrites_forbidden\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rewrites_forbidden</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for excluding some names, e.g. `[-my_lemma, -my_theorem]`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rewrites_forbidden","kind":"def","line":1715,"name":"Lean.Parser.Tactic.rewrites_forbidden","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1715-L1718"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.apply?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">apply?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.apply?","kind":"def","line":1706,"name":"Lean.Parser.Tactic.apply?","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1706-L1713"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.exact?\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">exact?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.exact?","kind":"def","line":1696,"name":"Lean.Parser.Tactic.exact?","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1696-L1704"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.applyRules\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">applyRules</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.applyRules","kind":"def","line":1670,"name":"Lean.Parser.Tactic.applyRules","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1670-L1693"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.applyAssumption\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">applyAssumption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.applyAssumption","kind":"def","line":1647,"name":"Lean.Parser.Tactic.applyAssumption","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1647-L1668"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.solveByElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">solveByElim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.solveByElim","kind":"def","line":1607,"name":"Lean.Parser.Tactic.solveByElim","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1607-L1645"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.using_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">using_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for using all lemmas labelled with an attribute in `solve_by_elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.using_","kind":"def","line":1599,"name":"Lean.Parser.Tactic.SolveByElim.using_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1599-L1600"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.args\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for adding and removing terms in `solve_by_elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.args","kind":"def","line":1597,"name":"Lean.Parser.Tactic.SolveByElim.args","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1597-L1598"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.arg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for adding or removing a term, or `*`, in `solve_by_elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.arg","kind":"def","line":1595,"name":"Lean.Parser.Tactic.SolveByElim.arg","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1595-L1596"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.star\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">star</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for including all local hypotheses in `solve_by_elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.star","kind":"def","line":1593,"name":"Lean.Parser.Tactic.SolveByElim.star","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1593-L1594"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.erase\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">erase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for omitting a local hypothesis in `solve_by_elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.erase","kind":"def","line":1591,"name":"Lean.Parser.Tactic.SolveByElim.erase","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1591-L1592"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.symmSaturate\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">symmSaturate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.symmSaturate","kind":"def","line":1585,"name":"Lean.Parser.Tactic.symmSaturate","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1585-L1587"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.symm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">symm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.symm","kind":"def","line":1577,"name":"Lean.Parser.Tactic.symm","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1577-L1583"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticAc_nf_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAc_nf_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAc_nf_","kind":"def","line":1574,"name":"Lean.Parser.Tactic.tacticAc_nf_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1574-L1575"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.normCastAddElim\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">normCastAddElim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`norm_cast_add_elim foo` registers `foo` as an elim-lemma in `norm_cast`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.normCastAddElim","kind":"def","line":1554,"name":"Lean.Parser.Tactic.normCastAddElim","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1554-L1557"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.pushCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">pushCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.pushCast","kind":"def","line":1518,"name":"Lean.Parser.Tactic.pushCast","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1518-L1552"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticNorm_cast__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticNorm_cast__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticNorm_cast__","kind":"def","line":1514,"name":"Lean.Parser.Tactic.tacticNorm_cast__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1514-L1515"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAssumption_mod_cast_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast_","kind":"def","line":1477,"name":"Lean.Parser.Tactic.tacticAssumption_mod_cast_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1477-L1477"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.normCast0\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">normCast0</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.normCast0","kind":"def","line":1467,"name":"Lean.Parser.Tactic.normCast0","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1467-L1468"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.acNf0\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">acNf0</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.acNf0","kind":"def","line":1464,"name":"Lean.Parser.Tactic.acNf0","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1464-L1465"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticBv_omega</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.\n`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega","kind":"def","line":1462,"name":"Lean.Parser.Tactic.tacticBv_omega","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1462-L1462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.omega\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">omega</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.omega","kind":"def","line":1425,"name":"Lean.Parser.Tactic.omega","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1425-L1455"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.nativeDecide\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nativeDecide</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`native_decide` is a synonym for `decide +native`.\nIt will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```lean\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.nativeDecide","kind":"def","line":1401,"name":"Lean.Parser.Tactic.nativeDecide","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1401-L1416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.decide\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">decide</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.decide","kind":"def","line":1329,"name":"Lean.Parser.Tactic.decide","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1329-L1399"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.revert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span>.<span class=\"name\">revert</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\">DecideConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If true (default: false), then when preprocessing, removes irrelevant variables and reverts the local context.\nA variable is *relevant* if it appears in the target, if it appears in a relevant variable,\nor if it is a proposition that refers to a relevant variable. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.revert","kind":"def","line":1327,"name":"Lean.Parser.Tactic.DecideConfig.revert","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1327-L1327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.zetaReduce\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span>.<span class=\"name\">zetaReduce</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\">DecideConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If true (default: true), then when preprocessing the goal, do zeta reduction to attempt to eliminate free variables. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.zetaReduce","kind":"def","line":1323,"name":"Lean.Parser.Tactic.DecideConfig.zetaReduce","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1323-L1323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.native\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span>.<span class=\"name\">native</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\">DecideConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If true (default: false), then uses the native code compiler to evaluate the `Decidable` instance,\nadmitting the result via the axiom `Lean.ofReduceBool`.  This can be significantly more efficient,\nbut it is at the cost of increasing the trusted code base, namely the Lean compiler\nand all definitions with an `@[implemented_by]` attribute.\nThe instance is only evaluated once. The `native_decide` tactic is a synonym for `decide +native`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.native","kind":"def","line":1321,"name":"Lean.Parser.Tactic.DecideConfig.native","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1321-L1321"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.kernel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span>.<span class=\"name\">kernel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\">DecideConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If true (default: false), then use only kernel reduction when reducing the `Decidable` instance.\nThis is more efficient, since the default mode reduces twice (once in the elaborator and again in the kernel),\nhowever kernel reduction ignores transparency settings. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.kernel","kind":"def","line":1315,"name":"Lean.Parser.Tactic.DecideConfig.kernel","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1315-L1315"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">kernel </span><span class=\"fn\">native </span><span class=\"fn\">zetaReduce </span><span class=\"fn\">revert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\">DecideConfig</a></div></div>","info":{"doc":"","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig.mk","kind":"ctor","line":1311,"name":"Lean.Parser.Tactic.DecideConfig.mk","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1311-L1311"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">DecideConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Configuration for the `decide` tactic family.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.DecideConfig","kind":"structure","line":1308,"name":"Lean.Parser.Tactic.DecideConfig","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1308-L1327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticLetI__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticLetI__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`letI` behaves like `let`, but inlines the value instead of producing a `let` term. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLetI__","kind":"def","line":1306,"name":"Lean.Parser.Tactic.tacticLetI__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1306-L1306"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticHaveI__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticHaveI__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHaveI__","kind":"def","line":1303,"name":"Lean.Parser.Tactic.tacticHaveI__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1303-L1303"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.runTac\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runTac</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `run_tac doSeq` tactic executes code in `TacticM Unit`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.runTac","kind":"def","line":1299,"name":"Lean.Parser.Tactic.runTac","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1299-L1300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.substEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">substEqs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.substEqs","kind":"def","line":1293,"name":"Lean.Parser.Tactic.substEqs","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1293-L1297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAnd_intros</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`and_intros` applies `And.intro` until it does not make progress. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros","kind":"def","line":1289,"name":"Lean.Parser.Tactic.tacticAnd_intros","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1289-L1290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.replace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">replace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.replace","kind":"def","line":1258,"name":"Lean.Parser.Tactic.replace","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1258-L1287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNomatch_,,»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tacticNomatch_,,»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The tactic `nomatch h` is shorthand for `exact nomatch h`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNomatch_,,»","kind":"def","line":1255,"name":"Lean.Parser.Tactic.«tacticNomatch_,,»","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1255-L1256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticNofun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticNofun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticNofun","kind":"def","line":1250,"name":"Lean.Parser.Tactic.tacticNofun","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1250-L1250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacIfThenElse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacIfThenElse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacIfThenElse","kind":"def","line":1229,"name":"Lean.Parser.Tactic.tacIfThenElse","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1229-L1244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacDepIfThenElse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacDepIfThenElse</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacDepIfThenElse","kind":"def","line":1212,"name":"Lean.Parser.Tactic.tacDepIfThenElse","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1212-L1227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.congr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">congr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ f as ≍ f bs`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.congr","kind":"def","line":1201,"name":"Lean.Parser.Tactic.congr","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1201-L1209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tacticExists_,,»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»","kind":"def","line":1198,"name":"Lean.Parser.Tactic.«tacticExists_,,»","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1198-L1199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.sleep\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sleep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.sleep","kind":"def","line":1188,"name":"Lean.Parser.Tactic.sleep","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1188-L1192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticUnhygienic_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_","kind":"def","line":1186,"name":"Lean.Parser.Tactic.tacticUnhygienic_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1186-L1186"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.specialize\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">specialize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.specialize","kind":"def","line":1164,"name":"Lean.Parser.Tactic.specialize","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1164-L1172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticStop_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_","kind":"def","line":1162,"name":"Lean.Parser.Tactic.tacticStop_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1162-L1162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace","kind":"def","line":1145,"name":"Lean.Parser.Tactic.dbgTrace","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1145-L1154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.split\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">split</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed using the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.split","kind":"def","line":1131,"name":"Lean.Parser.Tactic.split","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1131-L1143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.classical\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">classical</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance.\n\nNote that `classical` is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.classical","kind":"def","line":1122,"name":"Lean.Parser.Tactic.classical","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1122-L1129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticTrivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial","kind":"def","line":1112,"name":"Lean.Parser.Tactic.tacticTrivial","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1112-L1120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.repeat1'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">repeat1'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.repeat1'","kind":"def","line":1102,"name":"Lean.Parser.Tactic.repeat1'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1102-L1110"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.repeat'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">repeat'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.repeat'","kind":"def","line":1092,"name":"Lean.Parser.Tactic.repeat'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1092-L1100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRepeat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_","kind":"def","line":1076,"name":"Lean.Parser.Tactic.tacticRepeat_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1076-L1088"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.renameI\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">renameI</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.renameI","kind":"def","line":1073,"name":"Lean.Parser.Tactic.renameI","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1073-L1074"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.funCases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">funCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional\ncases principle.\n\nThe tactic invocation\n```\nfun_cases f x ... y ...`\n```\nis equivalent to\n```\ncases y, ... using f.fun_cases_unfolding x ...\n```\nwhere the arguments of `f` are used as arguments to `f.fun_cases_unfolding` or targets of the case\nanalysis, as appropriate.\n\nThe form\n```\nfun_cases f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe form `fun_cases f x y with | case1 => tac₁ | case2 x' ih => tac₂` works like with `cases`.\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.fun_cases_unfolding` theorem, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.fun_cases` instead.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.funCases","kind":"def","line":1042,"name":"Lean.Parser.Tactic.funCases","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1042-L1071"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.funInduction\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">funInduction</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `fun_induction` tactic is a convenience wrapper around the `induction` tactic to use the the\nfunctional induction principle.\n\nThe tactic invocation\n```\nfun_induction f x₁ ... xₙ y₁ ... yₘ\n```\nwhere `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to\n```\ninduction y₁, ... yₘ using f.induct_unfolding x₁ ... xₙ\n```\nwhere the arguments of `f` are used as arguments to `f.induct_unfolding` or targets of the\ninduction, as appropriate.\n\nThe form\n```\nfun_induction f\n```\n(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses\nthese arguments. An application of `f` is eligible if it is saturated and the arguments that will\nbecome targets are free variables.\n\nThe forms `fun_induction f x y generalizing z₁ ... zₙ` and\n`fun_induction f x y with | case1 => tac₁ | case2 x' ih => tac₂` work like with `induction.`\n\nUnder `set_option tactic.fun_induction.unfolding true` (the default), `fun_induction` uses the\n`f.induct_unfolding` induction principle, which will try to automatically unfold the call to `f` in\nthe goal. With `set_option tactic.fun_induction.unfolding false`, it uses `f.induct` instead.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.funInduction","kind":"def","line":1009,"name":"Lean.Parser.Tactic.funInduction","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L1009-L1040"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.cases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">cases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.cases","kind":"def","line":984,"name":"Lean.Parser.Tactic.cases","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L984-L1007"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.generalize\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">generalize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalize","kind":"def","line":975,"name":"Lean.Parser.Tactic.generalize","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L975-L982"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.generalizeArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">generalizeArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A `generalize` argument, of the form `term = x` or `h : term = x`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalizeArg","kind":"def","line":972,"name":"Lean.Parser.Tactic.generalizeArg","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L972-L973"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.induction\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">induction</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.induction","kind":"def","line":943,"name":"Lean.Parser.Tactic.induction","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L943-L970"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.elimTarget\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elimTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A target for the `induction` or `cases` tactic, of the form `e` or `h : e`.\n\nThe `h : e` syntax introduces a hypotheses of the form `h : e = _` in each goal,\nwith `_` replaced by the corresponding value of the target.\nIt is useful when `e` is not a free variable.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.elimTarget","kind":"def","line":935,"name":"Lean.Parser.Tactic.elimTarget","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L935-L942"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">inductionAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlts","kind":"def","line":929,"name":"Lean.Parser.Tactic.inductionAlts","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L929-L933"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">inductionAlt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlt","kind":"def","line":924,"name":"Lean.Parser.Tactic.inductionAlt","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L924-L928"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">inductionAltLHS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The left hand side of an induction arm, `| foo a b c` or `| @foo a b c`\nwhere `foo` is a constructor of the inductive type and `a b c` are the arguments\nto the constructor.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS","kind":"def","line":918,"name":"Lean.Parser.Tactic.inductionAltLHS","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L918-L923"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticLet'__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Similar to `let`, but using `refine'` ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'__","kind":"def","line":916,"name":"Lean.Parser.Tactic.tacticLet'__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L916-L916"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticHave'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Similar to `have`, but using `refine'` ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'","kind":"def","line":914,"name":"Lean.Parser.Tactic.tacticHave'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L914-L914"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRefine_lift'_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Similar to `refine_lift`, but using `refine'` ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_","kind":"def","line":912,"name":"Lean.Parser.Tactic.tacticRefine_lift'_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L912-L912"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.letrec","kind":"def","line":905,"name":"Lean.Parser.Tactic.letrec","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L905-L907"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticLet__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat => _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet__","kind":"def","line":903,"name":"Lean.Parser.Tactic.tacticLet__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L903-L903"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSuffices_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_","kind":"def","line":874,"name":"Lean.Parser.Tactic.tacticSuffices_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L874-L874"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticHave__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat => _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave__","kind":"def","line":807,"name":"Lean.Parser.Tactic.tacticHave__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L807-L835"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRefine_lift_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_","kind":"def","line":805,"name":"Lean.Parser.Tactic.tacticRefine_lift_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L805-L805"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.unfold\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfold</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.unfold","kind":"def","line":787,"name":"Lean.Parser.Tactic.unfold","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L787-L799"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.delta\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.delta","kind":"def","line":780,"name":"Lean.Parser.Tactic.delta","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L780-L785"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSimpa?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?!_","kind":"def","line":777,"name":"Lean.Parser.Tactic.tacticSimpa?!_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L777-L778"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSimpa?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?_","kind":"def","line":774,"name":"Lean.Parser.Tactic.tacticSimpa?_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L774-L775"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSimpa!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa!_","kind":"def","line":771,"name":"Lean.Parser.Tactic.tacticSimpa!_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L771-L772"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpa\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpa</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpa","kind":"def","line":755,"name":"Lean.Parser.Tactic.simpa","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L755-L769"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpaArgsRest\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpaArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The arguments to the `simpa` family tactics. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpaArgsRest","kind":"def","line":752,"name":"Lean.Parser.Tactic.simpaArgsRest","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L752-L753"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticDsimp?!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticDsimp?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticDsimp?!_","kind":"def","line":750,"name":"Lean.Parser.Tactic.tacticDsimp?!_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L750-L750"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dsimpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dsimpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimpTrace","kind":"def","line":746,"name":"Lean.Parser.Tactic.dsimpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L746-L747"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dsimpTraceArgsRest\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dsimpTraceArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The common arguments of `dsimp?` and `dsimp?!`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimpTraceArgsRest","kind":"def","line":743,"name":"Lean.Parser.Tactic.dsimpTraceArgsRest","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L743-L744"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp_all?!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSimp_all?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp_all?!_","kind":"def","line":741,"name":"Lean.Parser.Tactic.tacticSimp_all?!_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L741-L741"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpAllTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpAllTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpAllTrace","kind":"def","line":737,"name":"Lean.Parser.Tactic.simpAllTrace","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L737-L738"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpAllTraceArgsRest\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpAllTraceArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The common arguments of `simp_all?` and `simp_all?!`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpAllTraceArgsRest","kind":"def","line":734,"name":"Lean.Parser.Tactic.simpAllTraceArgsRest","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L734-L735"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp?!_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSimp?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp?!_","kind":"def","line":732,"name":"Lean.Parser.Tactic.tacticSimp?!_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L732-L732"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpTrace","kind":"def","line":718,"name":"Lean.Parser.Tactic.simpTrace","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L718-L729"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpTraceArgsRest\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpTraceArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The common arguments of `simp?` and `simp?!`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpTraceArgsRest","kind":"def","line":715,"name":"Lean.Parser.Tactic.simpTraceArgsRest","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L715-L716"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dsimpArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dsimpArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A dsimp args list is a list of `dsimpArg`. This is the main argument to `dsimp`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimpArgs","kind":"def","line":712,"name":"Lean.Parser.Tactic.dsimpArgs","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L712-L713"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dsimpArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dsimpArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A `dsimpArg` is similar to `simpArg`, but it does not have the `simpStar` form\nbecause it does not make sense to use hypotheses in `dsimp`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimpArg","kind":"def","line":706,"name":"Lean.Parser.Tactic.dsimpArg","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L706-L710"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpArgs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A simp args list is a list of `simpArg`. This is the main argument to `simp`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpArgs","kind":"def","line":703,"name":"Lean.Parser.Tactic.simpArgs","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L703-L704"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A `simpArg` is either a `*`, `-lemma` or a simp lemma specification\n(which includes the `↑` `↓` `←` specifications for pre, post, reverse rewriting).\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpArg","kind":"def","line":697,"name":"Lean.Parser.Tactic.simpArg","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L697-L701"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.dsimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">dsimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimp","kind":"def","line":689,"name":"Lean.Parser.Tactic.dsimp","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L689-L695"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpAll\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpAll</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpAll","kind":"def","line":681,"name":"Lean.Parser.Tactic.simpAll","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L681-L687"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simp","kind":"def","line":659,"name":"Lean.Parser.Tactic.simp","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L659-L680"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpStar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpStar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The simp lemma specification `*` means to rewrite with all hypotheses ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpStar","kind":"def","line":657,"name":"Lean.Parser.Tactic.simpStar","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L657-L658"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpErase\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpErase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"An erasure specification `-thm` says to remove `thm` from the simp set ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpErase","kind":"def","line":655,"name":"Lean.Parser.Tactic.simpErase","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L655-L656"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpLemma\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A simp lemma specification is:\n* optional `↑` or `↓` to specify use before or after entering the subterm\n* optional `←` to use the lemma backward\n* `thm` for the theorem to rewrite with\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpLemma","kind":"def","line":648,"name":"Lean.Parser.Tactic.simpLemma","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L648-L654"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpPost\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpPost</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Use this rewrite rule after entering the subterms ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPost","kind":"def","line":646,"name":"Lean.Parser.Tactic.simpPost","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L646-L647"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.simpPre\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">simpPre</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Use this rewrite rule before entering the subterms ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPre","kind":"def","line":644,"name":"Lean.Parser.Tactic.simpPre","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L644-L645"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.discharger\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">discharger</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The discharger clause of `simp` and related tactics.\nThis is a tactic used to discharge the side conditions on conditional rewrite rules.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.discharger","kind":"def","line":638,"name":"Lean.Parser.Tactic.discharger","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L638-L642"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.injections\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">injections</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injections","kind":"def","line":632,"name":"Lean.Parser.Tactic.injections","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L632-L636"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.injection\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">injection</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injection","kind":"def","line":617,"name":"Lean.Parser.Tactic.injection","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L617-L630"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRwa__\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRwa__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rwa` is short-hand for `rw; assumption`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRwa__","kind":"def","line":614,"name":"Lean.Parser.Tactic.tacticRwa__","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L614-L615"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rwSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rwSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwSeq","kind":"def","line":606,"name":"Lean.Parser.Tactic.rwSeq","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L606-L611"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rewriteSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (occs := .pos L) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`(occs := .neg L)` allows skipping specified occurrences.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq","kind":"def","line":582,"name":"Lean.Parser.Tactic.rewriteSeq","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L582-L601"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rwRuleSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A `rwRuleSeq` is a list of `rwRule` in brackets. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq","kind":"def","line":579,"name":"Lean.Parser.Tactic.rwRuleSeq","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L579-L580"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rwRule\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rwRule</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"If `thm` is a theorem `a = b`, then as a rewrite rule,\n* `thm` means to replace `a` with `b`, and\n* `← thm` means to replace `b` with `a`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRule","kind":"def","line":573,"name":"Lean.Parser.Tactic.rwRule","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L573-L578"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.letToHave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">letToHave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Transforms `let` expressions into `have` expressions when possible.\n- `let_to_have` transforms `let`s in the target.\n- `let_to_have at h` transforms `let`s in the given local hypothesis.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.letToHave","kind":"def","line":566,"name":"Lean.Parser.Tactic.letToHave","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L566-L571"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.liftLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">liftLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Lifts `let` and `have` expressions within a term as far out as possible.\nIt is like `extract_lets +lift`, but the top-level lets at the end of the procedure\nare not extracted as local hypotheses.\n\n- `lift_lets` lifts let expressions in the target.\n- `lift_lets at h` lifts let expressions at the given local hypothesis.\n\nFor example,\n```lean\nexample : (let x := 1; x) = 1 := by\n  lift_lets\n  -- ⊢ let x := 1; x = 1\n  ...\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.liftLets","kind":"def","line":548,"name":"Lean.Parser.Tactic.liftLets","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L548-L564"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.extractLets\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">extractLets</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Extracts `let` and `have` expressions from within the target or a local hypothesis,\nintroducing new local definitions.\n\n- `extract_lets` extracts all the lets from the target.\n- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.\n  Using `_` for a name leaves it unnamed.\n- `extract_lets x y z at h` operates on the local hypothesis `h` instead of the target.\n\nFor example, given a local hypotheses if the form `h : let x := v; b x`, then `extract_lets z at h`\nintroduces a new local definition `z := v` and changes `h` to be `h : b z`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.extractLets","kind":"def","line":534,"name":"Lean.Parser.Tactic.extractLets","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L534-L546"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.show","kind":"def","line":528,"name":"Lean.Parser.Tactic.show","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L528-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.changeWith\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">changeWith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.changeWith","kind":"def","line":521,"name":"Lean.Parser.Tactic.changeWith","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L521-L526"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.change\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">change</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.change","kind":"def","line":513,"name":"Lean.Parser.Tactic.change","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L513-L519"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.location\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">location</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.location","kind":"def","line":502,"name":"Lean.Parser.Tactic.location","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L502-L511"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.locationHyp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">locationHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A sequence of one or more locations at which a tactic should operate. These can include local\nhypotheses and `⊢`, which denotes the goal.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationHyp","kind":"def","line":496,"name":"Lean.Parser.Tactic.locationHyp","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L496-L500"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.locationType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">locationType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `⊢` location refers to the current goal. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationType","kind":"def","line":493,"name":"Lean.Parser.Tactic.locationType","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L493-L494"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.locationWildcard\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">locationWildcard</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `*` location refers to all hypotheses and the goal. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationWildcard","kind":"def","line":490,"name":"Lean.Parser.Tactic.locationWildcard","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L490-L491"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.config\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Optional configuration option for tactics. (Deprecated. Replace `(config)?` with `optConfig`.) ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.config","kind":"def","line":487,"name":"Lean.Parser.Tactic.config","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L487-L488"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.optConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">optConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Configuration options for tactics. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.optConfig","kind":"def","line":484,"name":"Lean.Parser.Tactic.optConfig","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L484-L485"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.configItem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">configItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"A configuration item for a tactic configuration. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.configItem","kind":"def","line":481,"name":"Lean.Parser.Tactic.configItem","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L481-L482"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.valConfigItem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">valConfigItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`(opt := val)` sets the `opt` configuration option to `val`.\n\nAs a special case, `(config := ...)` sets the entire configuration.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.valConfigItem","kind":"def","line":475,"name":"Lean.Parser.Tactic.valConfigItem","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L475-L480"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.negConfigItem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">negConfigItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`-opt` is short for `(opt := false)`. It sets the `opt` configuration option to `false`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.negConfigItem","kind":"def","line":471,"name":"Lean.Parser.Tactic.negConfigItem","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L471-L474"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.posConfigItem\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">posConfigItem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`+opt` is short for `(opt := true)`. It sets the `opt` configuration option to `true`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.posConfigItem","kind":"def","line":467,"name":"Lean.Parser.Tactic.posConfigItem","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L467-L470"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticInfer_instance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance","kind":"def","line":465,"name":"Lean.Parser.Tactic.tacticInfer_instance","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L465-L465"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAdmit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`admit` is a synonym for `sorry`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit","kind":"def","line":459,"name":"Lean.Parser.Tactic.tacticAdmit","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L459-L459"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry","kind":"def","line":456,"name":"Lean.Parser.Tactic.tacticSorry","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L456-L456"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.acRfl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">acRfl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.acRfl","kind":"def","line":436,"name":"Lean.Parser.Tactic.acRfl","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L436-L445"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRfl'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'","kind":"def","line":434,"name":"Lean.Parser.Tactic.tacticRfl'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L434-L434"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.applyRfl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">applyRfl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"The same as `rfl`, but without trying `eq_refl` at the end.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.applyRfl","kind":"def","line":418,"name":"Lean.Parser.Tactic.applyRfl","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L418-L421"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRfl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl","kind":"def","line":411,"name":"Lean.Parser.Tactic.tacticRfl","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L411-L416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.eqRefl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">eqRefl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.eqRefl","kind":"def","line":408,"name":"Lean.Parser.Tactic.eqRefl","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L408-L409"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.fail\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">fail</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`fail msg` is a tactic that always fails, and produces an error using the given message. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.fail","kind":"def","line":405,"name":"Lean.Parser.Tactic.fail","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L405-L406"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.«tactic_&lt;;&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tactic_&lt;;&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">TrailingParserDescr</a></div></div>","info":{"doc":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»","kind":"def","line":398,"name":"Lean.Parser.Tactic.«tactic_<;>_»","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L398-L403"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticTry_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`try tac` runs `tac` and succeeds even if `tac` failed. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_","kind":"def","line":392,"name":"Lean.Parser.Tactic.tacticTry_","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L392-L392"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rotateRight\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rotateRight</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateRight","kind":"def","line":385,"name":"Lean.Parser.Tactic.rotateRight","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L385-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rotateLeft</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft","kind":"def","line":378,"name":"Lean.Parser.Tactic.rotateLeft","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L378-L383"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.first\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">first</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.first","kind":"def","line":375,"name":"Lean.Parser.Tactic.first","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L375-L376"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withUnfoldingAll</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll","kind":"def","line":369,"name":"Lean.Parser.Tactic.withUnfoldingAll","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L369-L373"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withReducibleAndInstances</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances","kind":"def","line":363,"name":"Lean.Parser.Tactic.withReducibleAndInstances","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L363-L367"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.withReducible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withReducible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducible","kind":"def","line":357,"name":"Lean.Parser.Tactic.withReducible","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L357-L361"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.paren","kind":"def","line":350,"name":"Lean.Parser.Tactic.paren","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L350-L355"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">failIfSuccess</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`fail_if_success t` fails if the tactic `t` succeeds. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess","kind":"def","line":347,"name":"Lean.Parser.Tactic.failIfSuccess","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L347-L348"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.traceMessage\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">traceMessage</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`trace msg` displays `msg` in the info view. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceMessage","kind":"def","line":344,"name":"Lean.Parser.Tactic.traceMessage","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L344-L345"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.traceState\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">traceState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`trace_state` displays the current state in the info view. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceState","kind":"def","line":341,"name":"Lean.Parser.Tactic.traceState","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L341-L342"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.done\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">done</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`done` succeeds iff there are no remaining goals. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.done","kind":"def","line":338,"name":"Lean.Parser.Tactic.done","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L338-L339"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.skip\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">skip</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`skip` does nothing. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.skip","kind":"def","line":335,"name":"Lean.Parser.Tactic.skip","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L335-L336"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.focus\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">focus</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.focus","kind":"def","line":329,"name":"Lean.Parser.Tactic.focus","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L329-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.anyGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">anyGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`any_goals tac` applies the tactic `tac` to every goal,\nconcatenating the resulting goals for successful tactic applications.\nIf the tactic fails on all of the goals, the entire `any_goals` tactic fails.\n\nThis tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.anyGoals","kind":"def","line":320,"name":"Lean.Parser.Tactic.anyGoals","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L320-L327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.allGoals\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">allGoals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.allGoals","kind":"def","line":312,"name":"Lean.Parser.Tactic.allGoals","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L312-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=&gt;_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tacticNext_=&gt;_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=>_»","kind":"def","line":308,"name":"Lean.Parser.Tactic.«tacticNext_=>_»","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L308-L310"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.case'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">case'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case'","kind":"def","line":295,"name":"Lean.Parser.Tactic.case'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L295-L301"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.case\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">case</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case","kind":"def","line":286,"name":"Lean.Parser.Tactic.case","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L286-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.right\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">right</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.right","kind":"def","line":275,"name":"Lean.Parser.Tactic.right","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L275-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.left\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">left</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.left","kind":"def","line":264,"name":"Lean.Parser.Tactic.left","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L264-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.constructor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">constructor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.constructor","kind":"def","line":258,"name":"Lean.Parser.Tactic.constructor","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L258-L262"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticExfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso","kind":"def","line":256,"name":"Lean.Parser.Tactic.tacticExfalso","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L256-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.refine'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refine'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine'","kind":"def","line":249,"name":"Lean.Parser.Tactic.refine'","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L249-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.refine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine","kind":"def","line":242,"name":"Lean.Parser.Tactic.refine","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L242-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.exact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`exact e` closes the main goal if its target type matches that of `e`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.exact","kind":"def","line":237,"name":"Lean.Parser.Tactic.exact","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L237-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.apply\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">apply</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.apply","kind":"def","line":226,"name":"Lean.Parser.Tactic.apply","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L226-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">falseOrByContra</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra","kind":"def","line":213,"name":"Lean.Parser.Tactic.falseOrByContra","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L213-L224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.contradiction\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">contradiction</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.contradiction","kind":"def","line":187,"name":"Lean.Parser.Tactic.contradiction","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L187-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.assumption\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">assumption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.assumption","kind":"def","line":181,"name":"Lean.Parser.Tactic.assumption","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L181-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.substVars\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">substVars</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.substVars","kind":"def","line":176,"name":"Lean.Parser.Tactic.substVars","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L176-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`subst x...` substitutes each hypothesis `x` with a definition found in the local context,\nthen eliminates the hypothesis.\n- If `x` is a local definition, then its definition is used.\n- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,\n  then `e` is used for the definition of `x`.\n\nIf `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.\nThis is similar to the `cases h` tactic.\n\nSee also: `subst_vars` for substituting all local hypotheses that have a defining equation.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.subst","kind":"def","line":162,"name":"Lean.Parser.Tactic.subst","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L162-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.clearValue\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"* `clear_value x...` clears the values of the given local definitions.\n  A local definition `x : α := v` becomes a hypothesis `x : α`.\n\n* `clear_value (h : x = _)` adds a hypothesis `h : x = v` before clearing the value of `x`.\n  This is short for `have h : x = v := rfl; clear_value x`.\n  Any value definitionally equal to `v` can be used in place of `_`.\n\n* `clear_value *` clears values of all hypotheses that can be cleared.\n  Fails if none can be cleared.\n\nThese syntaxes can be combined. For example, `clear_value x y *` ensures that `x` and `y` are cleared\nwhile trying to clear all other local definitions,\nand `clear_value (hx : x = _) y * with hx` does the same while first adding the `hx : x = v` hypothesis.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clearValue","kind":"def","line":145,"name":"Lean.Parser.Tactic.clearValue","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L145-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.clearValueArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearValueArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Argument for the `clear_value` tactic.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clearValueArg","kind":"def","line":141,"name":"Lean.Parser.Tactic.clearValueArg","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L141-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.clearValueHyp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearValueHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for creating a hypothesis before clearing values.\nIn `(hx : x = _)`, the value of `x` is unified with `_`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clearValueHyp","kind":"def","line":136,"name":"Lean.Parser.Tactic.clearValueHyp","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L136-L140"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.clearValueStar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearValueStar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Syntax for trying to clear the values of all local definitions.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clearValueStar","kind":"def","line":132,"name":"Lean.Parser.Tactic.clearValueStar","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L132-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clear","kind":"def","line":126,"name":"Lean.Parser.Tactic.clear","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L126-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.revert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">revert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.revert","kind":"def","line":120,"name":"Lean.Parser.Tactic.revert","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L120-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.rename\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rename</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rename","kind":"def","line":114,"name":"Lean.Parser.Tactic.rename","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L114-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.intros\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">intros</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`intros` repeatedly applies `intro` to introduce zero or more hypotheses\nuntil the goal is no longer a *binding expression*\n(i.e., a universal quantifier, function type, implication, or `have`/`let`),\nwithout performing any definitional reductions (no unfolding, beta, eta, etc.).\nThe introduced hypotheses receive inaccessible (hygienic) names.\n\n`intros x y z` is equivalent to `intro x y z` and exists only for historical reasons.\nThe `intro` tactic should be preferred in this case.\n\n## Properties and relations\n\n- `intros` succeeds even when it introduces no hypotheses.\n\n- `repeat intro` is like `intros`, but it performs definitional reductions\n  to expose binders, and as such it may introduce more hypotheses than `intros`.\n\n- `intros` is equivalent to `intro _ _ … _`,\n  with the fewest trailing `_` placeholders needed so that the goal is no longer a binding expression.\n  The trailing introductions do not perform any definitional reductions.\n\n## Examples\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet-bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n\nDoes not unfold definitions:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intros","kind":"def","line":55,"name":"Lean.Parser.Tactic.intros","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L55-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.intro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">intro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intro","kind":"def","line":30,"name":"Lean.Parser.Tactic.intro","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L30-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">withAnnotateState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with\nthe initial and final state of running tactic `t`.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState","kind":"def","line":23,"name":"Lean.Parser.Tactic.withAnnotateState","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L23-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Tactics.html#Lean.Parser.Tactic.as_aux_lemma\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">as_aux_lemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`as_aux_lemma => tac` does the same as `tac`, except that it wraps the resulting expression\ninto an auxiliary lemma. In some cases, this significantly reduces the size of expressions\nbecause the proof term is not duplicated.\n","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.as_aux_lemma","kind":"def","line":16,"name":"Lean.Parser.Tactic.as_aux_lemma","sourceLink":"https://github.com/leanprover/lean4/blob/797c613eb9b6d4ec95db23e3e00af9ac6657f24b/src/Init/Tactics.lean#L16-L21"}}],"imports":["Init.Notation"],"instances":[],"name":"Init.Tactics"}